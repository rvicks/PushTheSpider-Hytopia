Only this page
All pages
Powered by GitBook
1 of 61
HYTOPIA Developer Docs
Get Started
Welcome to the HYTOPIA Developer Documentation!

HYTOPIA is a modern games platform inspired by Minecraft, Roblox, and Rec Room.

With HYTOPIA you can create your own link-sharable, massively multiplayer games in a voxel-like style by writing TypeScript or JavaScript. All playable in a web browser on any device, natively on PC/Mac/Linux, on Android/iOS phones and tablets, and even as a Discord Activity with friends! 

Anything is possible, there are no boundaries, with HYTOPIA your imagination is the limit!


A block dodging game built from scratch in 2 hours with the HYTOPIA SDK.
Let's Dive In...
Getting Started

Dive into the HYTOPIA SDK by creating your first game, world map, and testing with local multiplayer.

Getting Started
Initial Setup
Before we begin building our first game, we need to setup our local developer environment and a sample project. Follow these steps.

Optional Prerequisite
We strongly recommend you join our developer Discord server! Our developer server is a great place to showcase your work, chat with other developers, quickly get technical questions answered, and much more.

You can join our developer Discord server here: https://discord.gg/hytopia

1. Install Bun
HYTOPIA uses Bun as its JavaScript runtime.

Mac or Linux - Bun Install
Copy
# Open your terminal and run:
curl -fsSL https://bun.sh/install | bash
Windows - Bun Install
Copy
# Open your terminal and run:
powershell -c "irm bun.sh/install.ps1 | iex"
2. Create and initialize your project
Open your terminal and run:

Copy
# Install the HYTOPIA SDK package globally (If you haven't already)
bun install -g hytopia

# Navigate to your desired directory
cd ~/Desktop

# Create a new project directory
mkdir hytopia-demo
cd hytopia-demo

# Make sure we have the latest Bun version
bun upgrade

# Initialize a HYTOPIA project from the SDK
bunx hytopia init
You should see a log confirming successful initialization. If you received an error on the bunx step to initialize the project, you likely need to upgrade your bun installation, run bun upgrade in your terminal.

3. Run the project
Start your HYTOPIA game server with:

Copy
# Run our game, --watch hot reloads the server on code changes.
bun --watch index.ts
This runs index.ts, the entry point of your game. Your server is now live at https://localhost:8080.

4. Play!
Go to hytopia.com/play.

When prompted for a server URL, enter https://localhost:8080.

Explore and enjoy your first HYTOPIA game!

Note: If you are continually prompted to enter a server url or receive another error when connecting to your server, your browser is likely blocking the self-signed SSL certificate used for localhost. 

You can quickly resolve this by visiting https://localhost:8080 in a new tab. You'll likely be prompted with a warning saying this website is insecure (Due to the self-signed certificate for local development). Click "Advanced" or "Continue to website" depending on the browser - this will cause your browser to allow connections to your local server. The page should load with just "OK" text shown.

Now, return to https://hytopia.com/play - you should now be able to connect without issues.

Brave Browser: If you have tried visiting https://localhost:8080 in a new tab, it loads, but you still can't connect through https://hytopia.com/play, if you're using a browser like Brave, or any browser with a built-in firewall, you can try disabling it for https://hytopia.com/play - this in most all cases will resolve connectivity with localhost on Brave and similar browsers.


The boilerplate game you should see if you followed all of the steps successfully.
Next Steps
Create Your First Game

Learn how to use the HYTOPIA SDK to build a simple game!

Create Your First Game
Now that you've completed the Initial Setup, let's create a simple game! In this walkthrough, we'll cover some fundamental concepts of building a game with the HYTOPIA SDK.

1. Open your favorite code editor
It's time to bust out our code editor. We recommend VSCode or Cursor, but you're free to use whatever you'd like. 

Now, open up the project directory in your code editor that we create in the Initial Setup. 

Your file tree should look something like this: 


2. Run & Connect To Your Server
Make sure your server is running. You can learn more about how to do this in the Initial Setup guide.

Also make sure you're connected to your running game server through https://hytopia.com/play so you can see your changes in real time as you follow this guide.

3. Building a world
In this example, we'll be using the world generated by default when we performed bunx hytopia init. However, in almost all cases you'll probably want to create your own world with its own textures, look and feel. You can do that by following the Build Your First World Map guide.

4. startServer() 
Open up the index.ts file in your editor. This is the entry point for your game. All HYTOPIA games are initialized with the startSever() function. This function internally handles all low-level game setup from initializing the physics engine, opening up the server to websocket connections, and more - all without you ever having to deal with any of those complexities.

startServer() expects a callback, which is the init function for your game. This init function is where all of the setup of your game should happen - loading your map, spawning initial entities, defining callback and tick callback logic, and more. After your init function is ran internally by startServer(), your server will open to connections. 

Copy
startServer(world => {
  // world is the default World instance of our game
  // This is where we should do all of our game setup.
  // After your setup logic completes, your server will
  // automatically open to player connections.
});
5. Create an Entity
Entities are a core concept in games, they often represent NPCs, player characters, interactable objects like vehicles, and more. In HYTOPIA, you'll use an Entity for any object in your game that is not a terrain block.

Entities internally are represented as a Rigid Body with one or more Colliders. This is what defines how they interact with the physical world. Such as colliding with walls, bouncing off of things they hit hard enough, rolling down slopes, and more.

If you're unfamiliar with what a Rigid Body or Collider is in the context of game development, here's a quick explanation:

Rigid Body: In a game physics engine, a rigid body is like a solid object that doesn't bend, stretch, or change shapeâ€”it stays the same no matter what happens to it. When you assign a rigid body to something in your game, you're telling the physics engine to handle its movement and interactions realistically. This means the object can move around, fall due to gravity, collide with other objects, and respond to forces just like things do in the real world.

Collider: A collider is an invisible shape attached to a game object that defines its physical boundaries for detecting collisions. Think of it as the object's "collision shape." It doesn't have to look exactly like the object; it can be a simple shape like a box or a sphere that roughly matches the object's size. Colliders allow the engine to calculate when two objects touch or overlap so you can trigger events like damaging a character when they fall and hit a block or picking up an item when they walk over it, and much more.

In this example, we'll create a basic spider entity.

Copy
import {
  startServer,
  ColliderShape, // import the ColliderShape enum
  Entity, // import the Entity class
  GameServer,
  PlayerEntity,
  RigidBodyType, // improt the RigidBodyType enum
} from 'hytopia';

startServer(world => {
  // .. Other init code hidden for this example...

  // spider hitbox is automatically calculated from the model & scale.
  const spider = new Entity({
    modelUri: 'models/npcs/spider.gltf',
    modelScale: 2.5,
    modelLoopedAnimations: [ 'idle' ],
  });

  // Spawn the spider in the world.
  spider.spawn(world, { x: 0, y: 10, z: -15 });
});
```
We've spawned a spider! It doesn't do much, but we've learned a lot here!

Here's some takeaways from this example

You can import any .gltf model into your game to represent your entities, just throw them into your projects assets/models/ directory.

You have full control over your entities scale, animation state, and much more.

You can spawn your spider when you're ready, by providing the world it spawns into, and the  coordinate to spawn it at in the world.

If all went well, we should see a spider. Also, notice those lines around our character and the spider? Those are the debug lines of our colliders attached to our Spider and Player Entity! This debug feature is super helpful for debugging our entities and their physical interactions in the world. You can enable debug lines by uncommenting world.simulation.enableDebugRendering(true) - be aware that debug lines can be laggy in larger worlds.


6. Make the spider do something...
This isn't much of a game yet... let's do something simple. How about every time our character runs into the spider it gets bounced in the direction we hit it from, and also has a bit of a spin applied to it? 

We can do this with a few lines of code and using an event!

Copy
// Our previous spider entity code...
const spider = new Entity({
  // ... previous spider init code...
});

spider.on(EntityEvent.ENTITY_COLLISION, ({ otherEntity, started }) => {
  if (!started) return;

  const hitDirection = otherEntity.directionFromRotation;
  console.log(hitDirection);
  const spiderMass = spiderEntity.mass;
  spiderEntity.applyImpulse({ 
    x: -hitDirection.x * 10 * spiderMass, 
    y: 10 * spiderMass, 
    z: -hitDirection.z * 10 * spiderMass ,
  });
});

// Spawn the spider in the world.
spider.spawn(world, { x: 0, y: 10, z: -15 });
After you've updated your code in your init function to use the on()method to register an event listener for the EntityEvent.ENTITY_COLLISIONevent, your spider when you run into it should behave something like this: 


7. Complete Code
Here's the complete code for our basic push the spider game.

Copy
import {
  startServer,
  Entity,
  EntityEvent,
  PlayerEntity,
  PlayerEvent
} from 'hytopia';

import worldMap from './assets/map.json';

/**
 * startServer is always the entry point for our game.
 * It accepts a single function where we should do any
 * setup necessary for our game. The init function is
 * passed a World instance which is the default
 * world created by the game server on startup.
 * 
 * Documentation: https://github.com/hytopiagg/sdk/blob/main/docs/server.startserver.md
 */

startServer(world => {
  /**
   * Enable debug rendering of the physics simulation.
   * This will overlay lines in-game representing colliders,
   * rigid bodies, and raycasts. This is useful for debugging
   * physics-related issues in a development environment.
   * For larger worlds, enabling this can cause performance
   * issues, which will be noticed as dropped frame rates
   * and higher RTT times.
   */
  // world.simulation.enableDebugRendering(true);

  /**
   * Load our map.
   * You can build your own map using https://build.hytopia.com
   * After building, hit export and drop the .json file in
   * the assets folder as map.json.
   */
  world.loadMap(worldMap);

  /**
   * Handle player joining the game. The onPlayerJoin
   * function is called when a new player connects to
   * the game. From here, we create a basic player
   * entity instance which automatically handles mapping
   * their inputs to control their in-game entity and
   * internally uses our default character controller.
   */
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    const playerEntity = new PlayerEntity({
      player,
      name: 'Player',
      modelUri: 'models/players/player.gltf',
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });
  
    playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
  });

  /**
   * Handle player leaving the game. The onPlayerLeave
   * function is called when a player leaves the game.
   * Because HYTOPIA is not opinionated on join and
   * leave game logic, we are responsible for cleaning
   * up the player and any entities associated with them
   * after they leave. We can easily do this by 
   * getting all the known PlayerEntity instances for
   * the player who left by using our world's EntityManager
   * instance.
   */
  world.on(PlayerEvent.LEFT_WORLD, ({ player }) => {
    world.entityManager.getAllPlayerEntities(player).forEach(entity => entity.despawn());
  };

  const spider = new Entity({
    modelUri: 'models/npcs/spider.gltf',
    modelScale: 2.5,
    modelLoopedAnimations: [ 'idle' ],
  });

  spider.on(EntityEvent.ENTITY_COLLISION, ({ otherEntity, started }) => {
    if (!started) return;

    const hitDirection = otherEntity.directionFromRotation;
    console.log(hitDirection);
    const spiderMass = spiderEntity.mass;
    spiderEntity.applyImpulse({ 
      x: -hitDirection.x * 10 * spiderMass, 
      y: 10 * spiderMass, 
      z: -hitDirection.z * 10 * spiderMass ,
    });
  });

  // Spawn the spider in the world.
  spider.spawn(world, { x: 0, y: 3, z: -15 });
});
8. Recap
That's it! We've made a really simple game of push the spider. This covered a lot of basics such as spawning entities, creating a collision callback, applying an impulse to move the entity, and more.

The best next steps to continue quickly learning all you can do with the HYTOPIA SDK is to...

Build your first world map: Build Your First World Map

Learn more from our official examples: Use Templates & Examples 

Next Steps
API Reference

Learn about the HYTOPIA SDK API Reference, one of the most useful information sources for developing.

API Reference
If you've ever used other SDK's or frameworks in the past, you're probably familiar with using an API Reference that provides complete documentation of all classes, constants, functions and more that the SDK or framework exposes.

HYTOPIA is no different, we provide a complete and always up-to-date API reference for the HYTOPIA SDK.

The HYTOPIA API Reference is one of the most used, and most helpful information sources available while developing with the HYTOPIA SDK. 

You can find the latest API Reference here.

A screenshot from the API reference, showcasing a number of the classes the HYTOPIA SDK exposes.
Next steps
Build Your First World Map

Learn how to use HYTOPIA tools to create your first world.

Build Your First World Map
Nearly all games will require you to build some kind of world map. Unless of course, you're building some space fighter game of sorts, which you can absolutely do with HYTOPIA ðŸ˜›

Let's get started building our first world map. Head over to our official map building tool at https://build.hytopia.com

1. Create a map at build.hytopia.com
For simplicity sake, we'll use the official HYTOPIA world map builder. Alternatively if you're feeling adventurous, the SDK exposes all of the features necessary to programmatically create your own map as well.

Once you've opened the map builder, you should see something like this:


You can select from a variety of default block types on the left, click in the world to place them, use a combination of the various fill tools, and more.

Once you're happy with your map, you're ready to export it and use it in your game.

Click the "Export" button near the bottom of the screen, you'll be prompted to download a .json file, this is your world map file. For this example, save it as map.json into the assets directory of your HYTOPIA project.

2. Load your map in your server
Now you're ready to load your map! We'll do this based on our boilerplate code for demonstration sake.

At the top of your index.ts file in the root of your project directory, import the map.

Copy
// ... your other imports
import worldMap from './assets/map.json';

// ... your code
Now, in your startServer init function, we need to load the map into the world. 

Copy
startServer(world => {
  world.loadMap(worldMap);
  
  // ... your other init code
});
That's it! 

Now, start your server, and connect to it like usual through https://hytopia.com/play.

You should be able to see your created map!

Some or all of my blocks are missing, or blacked out?

If some or all of your blocks are missing or blocked out, it's likely because you don't have the textures in your assets/blocks folder that the my-map.json file is looking for. Here's a few ways to remedy this.

Make sure you have the latest block textures, they will be included by default if you originally initialized your project with bunx hytpia init.

Check for what textures you have and don't have. Open your map.json in a text editor. At the top, you'll notice blockTypes - look at all the textureUri values and make sure the texture files they're pointing to exist in your assets directory. For example, a textureUri of blocks/gravel.png should be located in your project at assets/blocks/gravel.png . 

If you have a textureUri that does not have a file extension, such as blocks/grass this is a path to a cubemapped texture, it means you should have a folder at assets/blocks/grass with 6 files for each of the block's faces - +x.png, +y.png, +z.png, -x.png, -y.png, -z.png.

Next Steps
Enable Multiplayer Testing

Learn how to use ngrok.io to allow others to join and test your local HYTOPIA server.

Multiplayer Testing
Running your server locally and allowing friends or testers to connect to it is a great way to get feedback on your game or debug it with multiple players. You can quickly allow players to connect by using cloudflare's free tunneling service, cloudflared. 

1. Install cloudflared
First, install cloudflared on your the computer or server that will run your game server.

Follow this guide to install cloudflared.

2. Start your server without SSL
Local development by default uses SSL with a self-signed certificate, but a cloudflare tunnel will provision it's own SSL certificate. We need to disable the one our server uses to prevent conflicts. 

We can do this and run our game at the same time by running the following command in our terminal. Setting NODE_ENV=productionwill signal the server to not use it's own SSL certificate.

Copy
# Start our game server without SSL
NODE_ENV=production bun --watch index.ts
3. Start a tunnel
Next, open another terminal window and run the following command to start your cloudflared tunnel. This assumes your game is running on the default port, which is 8080.

Copy
# Start our tunnel!
cloudflared tunnel --url http://localhost:8080
Once started, you should see something like this: 


4. Share your tunnel link & play
Copy your tunnel link from your terminal. Your tunnel link will be different, but for context, in our previous example our example link was: 

Copy
https://sie-perception-directories-currency.trycloudflare.com
Your tunnel link will be different each time you start your tunnel!

You and others can now connect to your server by going to https://hytopia.com/play and entering your tunnel link when prompted to enter a server to connect to.

You can alternatively make players auto-join your server with a link by using the ?join=query parameter like this:

Copy
https://hytopia.com/play?join=sie-perception-directories-currency.trycloudflare.com
Just make sure you replace the value of joinwith your own tunnel url!

Next Steps
Use Templates & Examples

Start creating games from one of the many available examples and templates.

Use Templates & Examples
One of the best ways to learn is by example, or maybe there's a type of game you already know you'd like to build but you don't want to start from scratch. This is exactly what HYTOPIA templates & examples are for!

A template can be created from any example project in the HYTOPIA SDK repo, found here. The available examples are constantly changing, so be sure to check often!

How to use examples as templates
To start a new HYTOPIA project based on an example in the examples directory of the HYTOPIA SDK, you can use the hytopia init command with the --template flag.

For example, if we wanted to create a new project using the wall-dodge-game example as our template, we can run:

Copy
bunx hytopia init --template wall-dodge-game
The value used for --template can be any example project folder found in the examples directory of the SDK repository.

Submit examples for others
If you've created an interesting project with the HYTOPIA SDK that you'd like to be made available as an official example in the SDK repo, you can fork the HYTOPIA SDK repo, add your project as a folders in the examples directory, and submit a pull request to the HYTOPIA SDK repo for our team to review.

Next Steps
SDK Guides

Learn how to use more powerful HYTOPIA SDK features.

Default Assets
HYTOPIA provides a wide variety of defaults assets. This includes pre-made audio, block textures, maps, skyboxes, models, and more.

When you start your HYTOPIA project by following the Initial Setupexample, your project will add the @hytopia.com/assets package to your project. Your game server when ran will automatically recognize this package & its directory in node_modules/@hytopia.com/assets as containing the default available assets, which you are free to use in your game however you'd like. 

These assets can then be referenced in the same way as assets in your own project's assetsfolder. When your game is ran, the contents of the assetsfolder and @hytopia.com/assetare internally merged and server by the webserver. So, to access a model from the HYTOPIA assets that exists at node_modules/@hytopia.com/assets/models/npcs/zombie.gltfwhen creating an Entity for example, models/npcs/zombie.gltfbecomes the resolved model uri for the Entity constructor. 

You can find the latest assets available at anytime in the HYTOPIA assets package on NPM, here.

SDK Guides
Assets
All of the different types of content that make up your game are called "Assets". Assets can be music, sound effects, block textures, cubemaps, GLTF models, images, videos, and more.

Assets Directory
All of your assets must be placed in the assets folder at the root of your project project structure. If you created your project using the HYTOPIA boilerplate or a template, your asset folder will look something like this.


Asset Usage & URIs
Throughout the HYTOPIA SDK, you'll be required to provide a URI to some type of asset. Whether this be a URI for a model, an audio file, a texture, or something else. 

All asset URI's are provided relative to the assets folder. 

For example, if we created a new block type that used a texture called dirt.png and we specified the URI to find that texture as blocks/dirt.png, then the fully resolved path would be assets/blocks/dirt.png

Asset Subfolders
It's common to want to organize your assets into subfolders, you can do this in any way you'd like. Again, the only important thing is all your assets must exist as a child of your root assets folder.

For example, we could create a audio folder in our assets folder to hold our .mp3 and .wav sound files for out game. Maybe we want to organize it a bit better and make multiple subfolders for organization so our structure looks like assets/audio/songs and within the songs folder we put ambient music. When needing to provide an audio URI for say the Audio class, we'd then use something like audio/songs/my-song.mp3 .

Audio & SFX
Music and sound effects are a key piece to any enjoyable game. The Audio class allows you to create and control playback of both ambient and spatial music and sound effects seamlessly within your game.

Playing Ambient Audio
Audio supports a number of features, but let's start with the simplest. Let's say we want to just play some nice ambient music for all of our players. We can do that like so:

Copy
startServer(world => {
  // ... Rest of our game setup code
  
  const gameMusic = new Audio({
    uri: 'audio/music/ambience.mp3',
    loop: true, // Loop the music when it ends
    volume: 0.5, // Relative volume 0 to 1
  });
  
  gameMusic.play(world); // Play the music in our world
      
  // ... More game setup code, ordering doesn't matter for Audio
})
Playing Spatial Audio
Oftentimes in games we need to play spatial audio that originates at some point in 3D space of the game, either from a specific coordinate or an entity. In this example, let's play some audio that constantly originates from each player and starts playing when a player joins the game.

Copy
startSever(world => {
  // ... Other game code
  
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    const playerEntity = new PlayerEntity({
      player,
      modelUri: 'models/players/player.gltf', // resolves to assets/models/player.gltf
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });
    
    const playerSirenAudio = new Audio({
      uri: 'audio/sfx/siren.mp3',
      loop: true, // We could omit loop: true if we want this to be a one-shot, only playing once
      volume: 1, // loud, volume is 0 (ie 0%) to 1 (ie 100%)!
      attachedToEntity: playerEntity,
      // reference distance is the approximate block distance
      // a player can be to start hearing the audio, as they 
      // get closer to the source it'll get louder, up to the
      // volume value.
      referenceDistance: 20,
      // alternatively, we can have this audio spatially emit
      // from a fixed position by removing our attachedToEntity
      // value and instead providing
      // position: { x: 1, y: 5, z: 4 } 
    });
    
    playerSirenAudio.play(world);
  });
  
  // ... Other game code
});
Controlling Playback & Effects
Most audio playback settings and effects can be controlled while Audio is already playing. Effects will automatically be interpolated by the client for smooth transitions between effects. This means you can do interesting things like adjust playback speed, distortion, detune, volume, and more while audio plays.

Here's an example of how we can continuously speed up our audio playback of our game music over time.

Copy
startServer(world => {
  // ... Rest of our game setup code
  
  const gameMusic = new Audio({
    uri: 'audio/music/ambience.mp3',
    loop: true, // Loop the music when it ends
    volume: 0.5, // Relative volume 0 to 1
  });
  
  gameMusic.play(world); // Play the music in our world
  
  setInterval(() => {
    gameMusic.setPlaybackRate(gameMusic.playbackRate + 0.1);
  }, 1000); // Every 1 second (1000 milliseconds), increase speed!
      
  // ... More game setup code, ordering doesn't matter for Audio
})
Diving Deeper
The Audio class supports a wide variety of features and control through various exposed properties and methods. If you'd like to learn more, we recommend digging into the Audio API Reference that can be found here.

If there are features that we don't currently support for Audio that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Next Steps
Audio Manager

Documentation of the AudioManager, used to iterate and search all audio.

Audio API Reference

Learn more about the properties and methods exposed by the Audio class.

Audio Manager
In more complex games, it's common to have many difference pieces of audio playing at the same time. This can become cumbersome to track or manage, especially if you need to do things like perform operations on all types of one specific kind of audio.

Thankfully, we have the AudioManager that exposes ways to quickly retrieve and iterate all Audio playbacks in a world.

Accessing An AudioManager
The AudioManager is used as a singleton and automatically created for a given world instance. 

You can access the audio manager for a world like this:

Copy
world.audioManager
Using An AudioManager
The AudioManager exposes a number of ways to get different types of Audio for a world. Here's some examples of how to use it. 

Copy
// Returns an array of all loaded audio instances
// for the world
world.audioManager.getAllAudios(); // You can iterate and manipulate each audio from here with .forEach, etc.

// Returns an array of all loaded audio instances
// attached to the provided entity
world.audioManager.getAllEntityAttachedAudios(someEntity);

// Returns an array of all loaded looped audio instances
// with loop: true
world.audioManager.getAllLoopedAudios();

// Returns an array of all loaded one-shot audio instances
// that have loop: false, or omitted loop
world.audioManager.getAllOneshotAudios();
Diving Deeper
The AudioManager class is constantly evolving. You can find the latest AudioManager API Reference here.

If there are features that we don't currently support for AudioManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Blocks & Chunks
In HYTOPIA, a world's terrain is made up of blocks. A block is a 1x1x1 sized cube or any subdivided shape that can fit within a 1x1x1 cube.

These blocks are then organized and arranged in a structure called a chunk, which is made up by 16x16x16 blocks (4,096). 

Blocks also have textures, which are a single image applied to all faces for the block, or alternatively can be a texture image for each face of the block.

Manipulating blocks and chunks is key to creating games that have dynamic terrain, or terrain that can be constructed / destructed by players (Think similar to breaking/placing blocks in Minecraft).

The BlockType, BlockTypeRegistry, Chunk and ChunkLattice classes are all key to managing and manipulating the terrain blocks of a world.

Let's explore some very common uses of blocks, block types and chunks.


A HYTOPIA world, all worlds are made of blocks.
Setting And Removing Blocks
Here's a quick example showcasing setting and removing blocks. We'll set or remove a block every 1 second based on if a block is already set or not.

Note: With HYTOPIA, you must register a new block type with the world.blockTypeRegistry before it can be set as a block in the world. You can learn about the BlockTypeRegistry here.

Copy
// You could place this code in your game setup function, or any callback, etc.
// There's no SDK opinionation on where or how you set/remove blocks.

// Create and register a new generic block type for gravel.
// Note: When you use world.loadMap, a number of block types will
// be preloaded. You can view them by console.log(world.blockTypeRegistry.getAllBlockTypes());
// Or look at the "blockTypes" property in your assets/map.json
const gravelBlockType = world.blockTypeRegistry.registerGenericBlockType({
  id: 1, // must be between 1 and 255, cannot be 0, 0 is reserved for air or "no block".
  textureUri: 'blocks/gravel.png',
  name: 'Gravel',
});

setInterval(() => { // Every second, if a block is set, remove it. If not, set it.
  const coordinate = { x: 0, y: 1, z: 0 }; 
  const hasBlock = world.chunkLattice.hasBlock(coordinate);
  const blockTypeId !hasBlock ? gravelBlockType.id : 0; // 0 = no block, which removes the block
  
  world.chunkLattice.setBlock(blockTypeId);
}, 1000)
Limitations Of Blocks
Within HYTOPIA, blocks are fixed cubes that cannot be translated or rotated. Think of them like the ground, walls, etc that are unmovable. 

In some cases, you may want blocks that can interact with the physical world, be pushed around, perhaps a block that is a moving platform, etc. For this, you'll want to use Block Entities.

Next Steps
We strongly recommend you check out the following guides to get a better idea of different things you can do with block types, a block type registry, chunks and a chunk lattice.

Block Types

Learn more about block types.

Block Type Registry

Learn more about the Block Type Registry

Chunks

Learn more about Chunks

Chunk Lattice

Learn more about the Chunk Lattice.

Block Types
Block types define the properties of each unique kind of block in the world. Since a Chunk references blocks at specific coordinates using their block type, we don't need to repeatedly define all the properties for every block in a chunk. Instead, we simply assign a block type's ID. This makes everything more efficient and streamlined!

Creating A BlockType
You can create a BlockType by creating a new instance using the BlockType class. Remember though, before the world is aware of this block type and before it can be used to set blocks of that type in the world, we have to register it with the world.blockTypeRegistry .

Copy
// Create a block type
const bouncyBlockType = new BlockType({
  id: bouncyBlockId // must be between 1 and 255, cannot be 0, 0 is reserved for air or "no block".
  textureUri: 'blocks/clay.png',
  name: 'Bouncy Clay',
  customColliderOptions: {
    bounciness: 5,
  }
});

// Remember! You have to register it before you can use it in the world.
world.blockTypeRegistry.registerBlockType(bouncyBlockType);
Creating Block Types Via BlockTypeRegistry
If you want another, equivalent but syntactically a bit simpler way to create block types, you can do so through the world.blockTypeRegistry.

Let's use the blockTypeRegistry directly to create and register a block that looks like clay but makes players bounce when they touch it.

Copy
// This code can be anywhere, but typically you'd
// do something like this in your game's setup
// function for startServer(world => {}).

// Register the block type
const bouncyBlockId = 77;
world.blockTypeRegistry.registerGenericBlockType({
  id: bouncyBlockId // must be between 1 and 255, cannot be 0, 0 is reserved for air or "no block".
  textureUri: 'blocks/clay.png',
  name: 'Bouncy Clay',
  customColliderOptions: {
    bounciness: 5,
  }
});

// Use the registered block type, 
// set a block of this type at a coordinate in the world.
world.chunkLattice.setBlock({ x: 1, y: 0, z: -1 }, bouncyBlockId);
BlockType Textures
BlockTypes can have their texture defined as a single texture that applies to all faces of the block, or as a path to a directory that has a unique image for each face of the block.

Note: While texture images can technically be any resolution, we strongly recommend you keep your textures as a 24x24 pixel image to maintain HYTOPIA's stylistic consistency and rendering performance for player's game clients.

To use a single image for a textureUri, we can do so like this:

Copy
new BlockType({
  id: knockbackBlockId,
  textureUri: 'blocks/sand.png', // Uses 'assets/blocks/sand.png' image for all faces
  name: 'Knockback Sand',
});
To use a unique texture for each face of a block, we can provide a path to a folder for our textureUri. HYTOPIA will know to look for +x.png , +y.png , +z.png , -x.png , -y.png , -z.png in the provided folder uri.

Copy
new BlockType({
  id: knockbackBlockId,
  // Looks in the 'assets/blocks/grass' folder for a texture
  // for each block face. This resolves to using textures at
  // the following paths.
  // assets/blocks/grass/+x.png
  // assets/blocks/grass/+y.png
  // assets/blocks/grass/+z.png
  // assets/blocks/grass/-x.png
  // assets/blocks/grass/-y.png
  // assets/blocks/grass/-z.png
  textureUri: 'blocks/grass',
  name: 'Knockback Sand',
});
Liquid Block Types
Block types can be set as a "liquid". A liquid block type has a special effect added to it that makes it look like a liquid using the textureUri you provide, while also allowing entities to move through it. 

Here's an example of a block type that is a liquid

Copy
new BlockType({
  id: 12, // can be any id
  textureUri: 'blocks/water.png',
  name: 'Water',
  isLiquid: true
});
Liquids by default have no special physical properties other than they don't collide with entities. You can create your own fluid/liquid physics and mechanics using the block type collisions for when an entity enters or leaves the liquid.

Block Types With Collision & Contact Callbacks
Block types support setting a callback for when an entity starts and stops colliding with them, as well as a callback providing the amount of contact force for the start of the collision.

Note: As of now, entity collision callbacks with blocks do not return the coordinate of collision. We recognize this is extremely useful for determine what specific block coordinate an entiy collided with. We're working on implementing this, and you can expect the onEntityCollision callback signature to be updated to include the collision coordinate soon. 

Copy
const sandKnockbackBlockId = 55;
const sandKnockbackBlockType = new BlockType({
  id: knockbackBlockId,
  textureUri: 'blocks/sand.png',
  name: 'Knockback Sand',
});

sandKnockbackBlockType.on(BlockTypeEvent.ENTITY_COLLISION, ({ blockType, entity, started }) => {
  // block type will be sandKnockbackBlockType
  // entity is the entity that collided with the block
  // started is true if the collision started, false when the entity is no longer colliding
  entity.applyImpulse({ x: 0, y: 20, z: 0}); // apply vertical knockback shooting them up.
});

sandKnockbackBlockType.on(BlockTypeEvent.ENTITY_CONTACT_FORCE, ({ blockType, entity, contractForceData }) => {
  // block type will be sandKnockbackBlockType
  // entity is the entity that collided with the block
  // log the contact force data, or do something with it.
  console.log(contactForceData);  
});

world.blockTypeRegistry.registerBlockType(sandKnockbackBlockType);

world.chunkLattice.setBlock({ x: 0, y: 0, z: -3 });
Alternatively, you may have a block type that is already registered and you want to either set a collision callback on it at some point in your code, or even remove a collision callback.

We can do that as follows

Copy
// Let's assume block id 14 is lava
const lavaBlockType world.blockTypeRegistry.getBlockTypeId(14);

// Set the collision callback
lavaBlockType.on(BlockTypeEvent.ENTITY_COLLISION, ({ blockType, entity, started }) => {
  if (started) {
    // kill the entity by despawning it since it touched lava.
    entity.despawn();
  }
});

// Now, let's say later in our code lava suddenly no longer
// kills players for some reason, we can remove it if we want
// lava collisions to no longer have any logic when a entity collides with them
lavaBlockType.offAll(BlockTypeEvent.ENTITY_COLLISION);
Diving Deeper
The BlockType implementation is constantly evolving and having new features added to it. You can find the latest BlockType API Reference here.

If there are features that we don't currently support for BlockType that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Block Type Registry
Most games will have many block types, and keeping track of those block types is important for your own game systems and internal HYTOPIA systems.

This is where the BlockTypeRegistry comes into play. Allowing us to register, unregister, retrieve and iterate known BlockType instances of our world.

Accessing A BlockTypeRegistry
The BlockTypeRegistry is used as a singleton and automatically created for a given world instance.

You can access the block type registry for a world like this:

Copy
world.blockTypeRegistry
Registering Block Types
Before a block type can be set as a block at a coordinate in the world through world.chunkLattice.setBlock() or chunk.setBlock(), the block type must have been previously registered with the world.blockTypeRegistry through world.blockTypeRegistry.registerBlockType() or world.blockTypeRegistry.registerGenericBlockType().

In this example, let's dive into how to register a block type, as well as the difference between registerBlockType() and registerGenericBlockType()

Copy
// This usage of world.blockTypeRegistry.registerGenericBlockType()
const dirtBlock = world.blockTypeRegistry.registerGenericBlockType({
  id: 1,
  textureUri: 'blocks/dirt.png',
  name: 'Dirt'
});

// Is equivalent too this
const dirtBlock = new BlockType({
  id: 1,
  textureUri: 'blocks/dirt.png',
  name: 'Dirt'
});

world.blockTypeRegistry.registerBlockType(dirtBlock);

// Using either is a matter of preference and 
// convenience, internally they result in
// the same outcome.
Other BlockTypeRegistry Usage
The BlockTypeRegistry exposes ways to iterate known block types, or get registered block types by ID. Here's an example:

Copy
// Returns an array of all block types
// for the world
world.blockTypeRegistry.getAllBlockTypes();

// Returns the block type for the provided ID,
// or throws if the provide ID is not registered.
const id = 15
world.blockTypeRegistry.getBlockType(id);
Diving Deeper
The BlockTypeRegistry class is constantly evolving. You can find the latest BlockTypeRegistry API Reference here.

If there are features that we don't currently support for BlockTypeRegistry that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Chunks
A Chunk represents a 16x16x16 subsection of world block space in a world. To make the entirety of a world

Global, Local and Origin Coordinate Types
HYTOPIA uses 3 distinct coordinate types within the block and chunk systems. You'll encounter these different types through the argument signatures of various SDK functions and methods. All coordinates are a Vector3 object, comprised of an x, y and z property.

Global Coordinates - These are the simplest type of coordinates, they are coordinates within the context of the world and can be anything. 

Local Coordinates - These are coordinates local to a chunk. These coordinates may only have x, y and z values in the range of 0..15. For example, { x: 0, y: 10, z: 4 } is a valid local coordinate, but { x: -1, y: 0, z: 16 } is not.

Origin Coordinates - These are the origin coordinates of a chunk relative to the world. These coordinates are global to the world, but are constrained to only allowing x, y and z values that are increments of +/- 16, denoting the starting origin point of the chunk in the global world space. For example, { x: 0, y: 32, z: -16 } is a valid origin coordinate, but { x: 0, y: 14, z: -3 }, is not.

Data Structure
Chunks internally are represented as an array of 4,096 8-bit numbers. We are able to translate from this flat array to the local coordinate representation of each block coordinate using the following:

Copy
public static blockIndexToLocalCoordinate(index: number): Vector3 {
  return {
    x: index % CHUNK_SIZE,
    y: (index / CHUNK_SIZE | 0) % CHUNK_SIZE,
    z: index / (CHUNK_SIZE * CHUNK_SIZE) | 0,
  };
}
At this time, because chunks use an 8-bit number to represent the block type id of each block within the chunk, the unique number of block types is limited to 255 possible block types. Block type ID 0 is reserved as a magic number meaning "no block" or "air".

Creating, Spawning And Despawning Chunks
Created Chunks will not be added to the world until they are spawned. They also will not be removed from the world until they are despawned. When using something like world.chunkLattice.setBlock() to modify blocks in the world space, you don't need to worry about chunk spawning and despawning because it is internally managed, whereas if you manipulate and create/remove chunks directly, you'll need to explicitly use .spawn() and .despawn() .

Copy
const myChunk = new Chunk();

// Set all x and z plane blocks
for (let x = 0; x < 16; x++) {
  for (let z = 0; z < 16; z++) {
    // assume block id 5 is dirt, or some type we made previously for this example
    myChunk.setBlock({ x, y: 0, z }, 5); // local coordinate space
  }
}

myChunk.spawn(world);
.isSimulated vs .isSpawned
Chunks have multiple lifecycle states, these are despawned, spawned and simulated. 

Chunks have 2 readonly properties .isSimulated and .isSpawned to reflect the lifecycle state of the chunk.

We can use the following readonly properties of a chunk to determine the lifecycle state.

.isSimulated - The chunk has been completely loaded into the physics simulation and has internally represented colliders. If .isSimulated is true, the chunk is also guaranteed to have .isSpawned as true as well. 

.isSpawned - The chunk has been loaded and registered in the world's ChunkLattice, but may not be simulated in the physics engine yet. This is because chunk simulation is deferred and batched to the next tick for internal reasons. A chunk that has .isSimulated equal to true, is not guaranteed to also have .isSimulated equal to true.

In most cases, you will not need to think about lifecycle states because they are internally managed and handled, you simply need to use chunk .spawn() and .despawn() to control if a chunk is in the world or not.

Diving Deeper
The Chunk class is constantly evolving. You can find the latest Chunk API Reference here.

If there are features that we don't currently support for the Chunk that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Chunk Lattice
A world has a single instance of a ChunkLattice. The Chunk Lattice is used to retrieve, set, modify and remove chunks that make up the entirety of your game's world.

Accessing A ChunkLattice
The ChunkLattice is used as a singleton and automatically created for a given world instance.

You can access the chunk lattice for a world like this:

Copy
world.chunkLattice
Using A ChunkLattice
The ChunkLattice exposes a number of ways to get chunks, or block types for a world at given types of coordinates. Here's some examples. For a complete list, please see the ChunkLattice API Reference.

Copy
// Returns an array of all loaded chunks in the world
world.chunkLattice.getAllChunks();

// Returns the block type id set at the provided global coordinate in the world
world.chunkLattice.getBlock({ x: 0, y: 0, z: 0 });

// Returns the chunk at the provided chunk origin coordinate in the world.
// Origin coordinates must be in increments of +/- 16
// You can convert a global coordinate to an origin coordinate
// with the static method Chunk.globalCoordinateToOriginCoordinate();
world.chunkLattice.getChunk({ x: 16, y: 32, z: -16 });

// Returns true or false if a block is set at the provided
// global coordinate
world.chunkLattice.hasBlock({ x: 5, y: 0, z: -4 );

// Returns true or false if a chunk exists at the provided
// origin coordinate
world.chunkLattice.hasChunk({ x: -16, y: 16, z: -48 });

// Sets a block by block type id at the provided
// global coordinate
// Assume 5 is the id of a block type we previously registered
world.chunkLattice.setBlock({ x: 1, y: 2, z: 3 }, 5);  
An Example Of Iterating Chunks
Sometimes, you might want to iterate through every chunk in your world. We can do that with the ChunkLattice. The ChunkLattice represents the spatial representation of all the known chunks in our world, and allows us to iterate and manipulate the entire chunk and even block state of the world through it.

In this example, let's iterate through all our chunks and replace all of the set blocks in our world of block type id 4 (Let's say id 4 is a water block) with block type id 5 (Let's say id 5 is a lava block).

Copy
world.chunkLattice.getAllChunks().forEach(chunk => {
  // A array of 4096 elements, each as a number 0 to 255
  // representing a blockTypeId, or no block (if 0).
  const chunkBlocks = chunk.blocks; 
  
  chunkBlocks.forEach(blockTypeId, blockIndex => {
    if (blockTypeId === 4) {
      // Using Chunk static method blockIndexToLocalCoordiante to convert
      // the index from the flat blocks array to the equivalent x,y,z 
      // coordinate. We have to do this because chunks
      // store blocks as a flat array Uint8Array[4096] for efficiency.
      const localCoordinate = Chunk.blockIndexToLocalCoordinate(blockIndex); 
    
      chunk.setBlock(localCoordinate, 5); // replace with block type 5
    }
  });
});
Dynamic Chunk Load/Unload
Currently HYTOPIA does not automatically handle the dynamic loading and unloading of chunks in the ChunkLattice relative to player location in a game. If you want to take on the challenge or require exceptionally large maps in your world, at this time you'll need to implement your own version of dynamic chunk load/unload.

This can be used by a combination of checking player positions each tick, tracking all possible chunks manually, and loading/unloading chunk instances with chunk.spawn() and chunk.despawn() as needed.

We intend to build out and support this feature in the future.

Diving Deeper
The ChunkLattice class is constantly evolving. You can find the latest ChunkLattice API Reference here.

If there are features that we don't currently support for the ChunkLattice that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Camera
Controlling the perspective of a player in your game is critical for making a fun and enjoyable experience specific to how you want your game to play and feel. 

To do this, the HYTOPIA SDK allows you to control the Camera. In game development, a camera is the perspective that a player sees the world from.

HYTOPIA's camera controls expose everything you need to do things like first person perspective, over the shoulder camera perspectives, lock on targeting effects, cinematic panning and camera movement for cutscenes, spectating, field of view control over time for speed effects, and so much more.


Zoomed in cinematic perspective achieved with camera controls.
Accessing A Player Camera
Player cameras exist for all Player object. You can access their PlayerCamera as follow.

Copy
player.camera // returns an instance of the PlayerCamera for the specific player.
Camera Mode (First & Third Person)
The camera currently supports 2 modes. First person, and third person. These modes effect how the players mouse movements control the camera, as well as the relative perspective of the camera.

The camera mode defaults to third person.

Like all other camera properties, you can change the camera mode of a player at any place in your game logic.

Copy
player.camera.setMode(PlayerCameraMode.FIRST_PERSON)
Interacting with the PlayerCamera
All camera interactions are done through an automatically created PlayerCamera class instance assigned to a Player instance. We can access this the moment a player joins a game, or use it at any point in our game logic.

Let's do a quick example showing how we can create a first person perspective for our game with the default player model.

Copy
startServer(world => {
  // Other game setup code..

  // Notice we're setting the camera for players immediately
  // when they join, but we can use player.camera anywhere
  // in our game logic. Also notice that player.camera is
  // specific to each player, this allows us to control
  // the camera of each player independently.
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    const playerEntity = new PlayerEntity({ // Create an entity our newly joined player controls
      player,
      name: 'Player',
      modelUri: 'models/players/player.gltf',
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });

    // Setup a first person camera for the player
    // set first person mode
    player.camera.setMode(PlayerCameraMode.FIRST_PERSON); 

    // shift camrea up on Y axis so we see from "head" perspective.
    player.camera.setOffset({ x: 0, y: 0.4, z: 0 }); 

    // hide the head node from the model so we don't see it in the camera, this is just hidden for the controlling player.
    player.camera.setHiddenModelNodes([ 'head', 'neck' ]); 
    
    // Shift the camera forward so we are looking slightly in front of where the player is looking.
    player.camera.setForwardOffset(0.3); 
    
    // Spawn the player entity
    playerEntity.spawn(world, { x: 0, y: 3, z: 0 );
  });

  // Other game setup code...
});

First person perspective from our previous example

Another example of first-person perspective from our "payload-game" example.
Camera Attachment & Tracking
You can control the origin from which a player's camera sees by changing the entity or position it's attached to. By default, when a player join's a game, if they have a player entity created for them, their camera will automatically attach to their player entity. 

You can also make a player camera automatically track another entity or a fixed position as well. Attachments and tracking used independently or together allow you to create a number of camera perspectives for different game types and situations.

Here's an example of how we can attach our player's camera to a cow entity we've created in our game, and have the camera always track and look towards our player entity that we control.

Copy
startServer(world => {
  // .. other game setup

  const cow = new Entity({
    modelUri: 'models/cow.gltf',
    modelLoopedAnimations: [ 'idle' ],
    modelScale: 0.5,
    rigidBodyOptions: { // manually setting the cow collider shape
      type: RigidBodyType.DYNAMIC,
      enabledRotations: { x: false, y: true, z: false },
      colliders: [
        {
          shape: ColliderShape.BLOCK,
          halfExtents: { x: 0.3, y: 0.45, z: 0.5 },
        },
      ],
    },
  });

  cow.spawn(world, { x: 2, y: 3, z: 6 });

  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    const playerEntity = new PlayerEntity({
      player,
      name: 'Player',
      modelUri: 'models/player.gltf',
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });

    playerEntity.spawn(world, { x: 0, y: 10, z: 0 });

    // all camera properties, including attachments
    // and tracking can be changed anywhere in your game logic
    // at game runtime!
    player.camera.setAttachedToEntity(cow);
    player.camera.setTrackedEntity(playerEntity);
  });
  
  // .. rest of our game setup
}
This results in the following camera & perspective effect for the player.


Player camera attached to cow, tracking controlled player entity.
Camera Offsets
In different camera modes, you may need to offset the positioning of a camera relative to the entity or position it's attached to. Such as in a first person perspective where the camera should be placed where the "head" of the player's entity would be. Here's how we can control camera offset.

Copy
// Change the offset relative to the attached
// entity or position of the camera.
// The offset is applied relative to the 
// internally calculated origin point the camera
// attached to for the entity, or position.
player.camera.setOffset({ x: 0, y: 1, z: 0 }); 

// Change the forward offset of the camera.
// This is only supported in first person mode.
// A positive number move the camera towards 
// what would be the "face" of a player perspective,
// and a negative value shifts the camera towards the
// "back of the head" of a player perspective.
player.camera.setForwardOffset(0.3);

// Change the film offset. This shifts the camera
// perspective left or right relative to its 
// attachment. You can use this to achieve
// an over the shoulder effect in third-person
// for a fortnite like third-person perspective,
// or use it for a variety of other uses like
// cinematics. A positive value shifts the camera
// right, a negative value shifts it left.
// The client will smoothly interpolate changes
// to this.
player.camera.setFilmOffset(5);
Camera Perspective Effects
You can fully control common perspective effects of the camera. These include field of view (FOV) and zoom. Both of these are smoothly interpolated by the client anytime you change them, allowing you to create smooth fov and zoom related effects. For example, you can progressively set zoom over the course of 1 second of time to create a smooth "scope-zoom" effect in a shooter game.

 Here's some example usage of these effects

Copy
// Change the player's FOV to 90,
// giving a wider field of view.
// Default is a FOV of 75.
player.camera.setFov(90);

// Change the player's zoom giving
// a more zoomed in perspective
// relative to the camera's attachment point
// Default is a Zoom of 2
player.camera.setZoom(2)

// Increase FOV every 100ms,
// creating a warp speed
// visual effect
setInterval(() => {
  const currentFov = player.camera.fov;
  
  if (currentFov < 150) {
    player.camera.setFov(currentFov + 1);
  }
}, 100)
Hiding Attached Entity Model Parts
In first person mode, it's very common that you'll want your player's camera perspective to be from the position of where they player model's head would be. But what do you do about the head part of the model being in the way?...

Easy, our camera allows us to hide specific parts (model nodes) of the entity the camera is attached to, and they are only hidden for our player's camera perspective and not other players.

We can also hide model nodes in third person if needed, but it's less common.

Here's an example of how to hide model nodes. For this case, we'll hide our head for our player's camera.

Copy
// We can pass an array of substrings to
// setHiddenModelNodes() to hide any named 
// node in the .gltf model for the entity 
// our camera is attached to that matches
// a substring.
//
// For example, if a node is named head_eyes,
// a substring of 'head' would match it.
// Any node with 'head' anywhere in its name
// will be hidden.
player.camera.setHiddenModelNodes([ 'head' ]);
Diving Deeper
The PlayerCamera class is constantly evolving. You can find the latest PlayerCamera API Reference here.

If there are features that we don't currently support for PlayerCamera that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Chat & Commands
Oftentimes, games send chat messages to all players or to a specific set of players to relay important information. Additionally, chat commands are common in games as well, triggering specific behaviors or altering settings when players or a game admin enters some command in chat.

The HYTOPIA SDK allows you to fully control programmatically sending chat messages as well as defining your own chat commands with callbacks.

All chat and chat command functionality is accessed through an instance of the ChatManager class. This singleton is automatically created for each world instance and is accessible via world.chatManager.


A simple example of using chat messages to welcome and tell a player how to play when they join our game.
Sending Chat Messages
There's 2 different ways to send chat messages. The first is broadcasting, which will be received by all players, and the second is sending messages only to a specific player.

Here's a quick example.

Copy
startServer(world => {
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    // only the player that just joined will receive this message
    world.chatManager.sendPlayerMessage(player, 'Welcome to our game!');    
    
    // Send another message to the player on the next line of chat,
    // providing a third hex color argument to change the message color
    world.chatManager.sendPlayerMessage(player, 'Have fun!', '00FF00');
  });
  
  // Send a message every second to all connected players.
  setInterval(() => {
    world.chatManager.sendBroadcastMessage('Another second has passed!');
  }, 1000);
});
Listening For Chat Messages
You can specify a callback for anytime a message is sent by a player, or your game. 

This can be done with chat manager events and an event listener!

Here's a quick example.

Copy
startServer(world => {
  world.chatManager.on(ChatEvent.BROADCAST_MESSAGE, ({ player, message, color }) => {
    if (player) {
      console.log(`Player ${player.username} sent a new public message: ${message}`);
    } else {
      console.log(`The game sent a new message public message: ${message}`);
    }
  });
});
Creating Chat Commands
Registering chat commands, often preceded with / (but not required), is a great way to add quick functionality to your game, create your own admin level commands like /ban, and more.

You can register a new chat command with world.chatManager.registerCommand()

Here's a quick ping/pong example of chat commands.

Copy
startServer(world => {
  // Simple ping/pong command
  // args will be an array of space separated words following /ping
  // IE, "/ping hello world" would give args = ['hello', 'world']
  // Note: "hello /ping" will not work, since our message
  // must start with /ping to register as an invoked command.
  world.chatManager.registerCommand('/ping', (player, args, message) => {
    world.chatManager.sendPlayerMessage(player, 'pong!');
  });
  
  // Alternative ping command, showing that we don't need
  // to use "/"
  world.chatManager.registerCommand('ping', (player, args, message) => {
    world.chatManager.sendPlayerMessage(player.'No / pong!');
  });
});
It's important to note that only one callback can be registered to the same command at a time. If you invoke world.chatManager.registerCommand() with a previously registered command, the previously set callback will be discarded and the callback provided to the most recent invocation of world.chatManager.registerCommand() will be used.

Lastly, you can unregister commands altogether with world.chatManager.unregisterCommand()

Diving Deeper
The ChatManager class is constantly evolving. You can find the latest ChatManager API Reference here.

If there are features that we don't currently support for the ChatManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Entities
Entities are the core piece of any game. An entity is any object in the physical world of the game can move, interacts with physics, and more. Examples of an Entity can be anything from the character controlled by a player, a shop NPC, a vehicle, a movable block or platform, and so much more.

In short, anything that is not a permanently immovable block that makes up a world's terrain is likely best suited to be created as an entity.


A block entity constantly spinning, and 3 model entities smoothly tracking our player position.
Flexibility
Entities are highly flexible. The HYTOPIA SDK exposes the ability to fully control all aspects of an entity, including the rigid body and collider(s) representation of an entity within the game engine. The SDK will automatically assume and infer sane defaults for entities, but allows you to override any of them.

You can learn more about the Rigid Body and Colliders used to represent the physical nature of an entity here.

Learn more about Rigid Bodies

Learn more about Colliders

Block Entities vs Model Entities
Entities are represented by either a GLTF (.gltf) format model from your assets folder - we call these Model Entities. Or, by a size and block texture, we call these Block Entities.

Model Entities - Model entities are great for characters, enemies, NPCs, animals, unique terrain models that interact with the world, and much more

Block Entities - Block entities are great for moving platforms, blocks that can be push/pulled for various puzzle or terrain traversing, and more.

Creating & Spawning An Entity
Here's an example of how to create and then spawn an Entity. An entity will not exist in the game until its .spawn() method is called. An entity can be despawned at any time with .despawn(). Once an entity is despawned, it can be respawned again with .spawn() .

Copy
startServer(world => {
  // Enable debug rendering so we can see the collider shape
  // of our entities. Please note that enabling this in a large
  // world or with many entities spawned will severely impact
  // game client performance. This is because the lines to draw
  // the physics collider representations are sent to the client
  // every tick, and with a large world and/or many colliders, this
  // can be many megabytes of data, sending 60 times per second,
  // choking the websocket even on a local connection.
  world.simulation.enableDebugRendering(true);

  // Create a block entity that spawns
  // or despawns every second
  const blockEntity = new Entity({
    blockTextureUri: 'blocks/bricks.png', // A texture URI without a file extension will use a folder and look for the textures for each face in the folder (-x.png, +x.png, -y.png, +y.png, -z.png, +z.png)
    blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 },
    // The collider & rigid body will automatically be
    // inferred and created by the blockHalfExtents.
    // You may override this by using rigidBodyOptions.
    // blockHalfExtents will always represent the visual
    // size of the block entity, no matter its colliders.
  });
  
  setInterval(() => {
    if (blockEntity.isSpawned) {
      blockEntity.despawn();
    } else {
      blockEntity.spawn({ x: 4, y: 2, z: 6 });
    }
  }, 1000);
  
  // Create a skeleton entity (model entity), an approximate hitbox collider for
  // physics will be automatically generated based on the model itself and the scale.
  const skeletonEntity = new Entity({
    modelUri: 'models/npcs/skeleton.gltf',
    modelLoopedAnimations: [ 'idle' ],
    // Scale is the proportional model size relative 
    // to its size in its .gltf file
    modelScale: 0.8,
    rigidBodyOptions: {
      enabledRotations: { x: false, y: true, z: false }, // Only allow rotations around Y axis (Yaw)
    },
  });
});
Next Steps
Entities are incredibly powerful and support a variety of features. We strongly recommend you check out the following guides to gain a better understanding of the different things you can do with entities.

Animations

Learn more about controlling GLTF animations for Model Entities.

Block Entities

Learn more about block entities through common use cases and examples.

Entity Controllers

Learn more about entity controllers to create unique movement and behaviors.

Entity Manager

Learn how to use a world's Entity Manager to iterate entities in a world.

Model Entities

Learn more about model entities and GLTF model considerations.

Movement & Pathfinding

Learn how to use the SimpleCharacterController for pathfinding, or create your own controller.

Player Controlled Entities

Learn about the PlayerEntity and using player inputs to control player entity behavior.

Animations
Model Entities, which are entities that have a modelUri when created, can have their in-game animation state completely controlled and blended using the Entity animation methods.

Animations do not work with Block Entities.

GLTF Animations
The HYTOPIA SDK expects all possible animations of a model to be included in a model's .gltf file. Model animations are referenced by their name. For example, if your .gltf file has an animation called idle that you want to play and loop as soon as an entity spawns, you'd do that as follows:

Copy
const myEntity = new Entity({
  modelUri: 'models/npcs/cow.gltf',
  modelLoopedAnimations: [ 'idle' ], // animations here will play looped when entity spawns
  // .. the rest of your entity options
});
Types Of Animations
HYTOPIA currently supports two types of animations. 

Looped Animations - These are animations that will contiue to play over and over again from start to finish in a smooth manner until they are explicitly stopped.

One-shot Animations - These are animations that will play from start to finish only once, or until they are explicitly stopped or restarted.

Animation Blending & Playback
At this time, all played animations for a model entity are equally blended in the visual playback state of the entity in game. This means you can play multiple GLTF model animations at the same time and they will blend equally between the same model node that may be involved in multiple playing animations.

Starting And Stopping Animations
For model entities, we can easily start, stop and filter the played animations of an entity. Here's an example of how our DefaultCharacterController internally handles animation state changes based on player inputs.

Animation state is internally tracked - so invoking start or stop of animations that are in an irrelevant state won't cause unusual animation states or performance overhead.

Copy
// tickPlayerMovement is a method from BaseCharacterController
// it is called each tick when associated with an entity
// controlled by a player (PlayerEntity)
public tickPlayerMovement(inputState: PlayerInputState, orientationState: PlayerOrientationState, deltaTimeMs: number) {
  // current pressed keystate of the controlling 
  // player of the entity  has pressed this tick.
  const { w, a, s, d, sp, sh, ml } = inputState;
  
  // ... Other character controller logic

  if (this.isGrounded && (w || a || s || d)) {
    if (isRunning) {
      // Stop all animations that aren't run
      this.entity.stopModelAnimations(Array.from(this.entity.modelLoopedAnimations).filter(v => v !== 'run'));
      // Play run animation, if it's already playing it won't be restarted since it's looped
      this.entity.startModelLoopedAnimations([ 'run' ]);
    } else {
      // Stop all animations that aren't walk
      this.entity.stopModelAnimations(Array.from(this.entity.modelLoopedAnimations).filter(v => v !== 'walk'));
      // Play walk animation, if it's already playing it won't be restarted since it's looped
      this.entity.startModelLoopedAnimations([ 'walk' ]);
    }
  } else {
    // Stop all animations that aren't idle
    this.entity.stopModelAnimations(Array.from(this.entity.modelLoopedAnimations).filter(v => v !== 'idle'));
    // Play idle animation, if it's already playing it won't be restarted since it's looped
    this.entity.startModelLoopedAnimations([ 'idle' ]);
  }
  
  if (ml) { // player pressed the left mouse button
    // Play our animation named 'simple_interact' once./
    this.entity.startModelOneshotAnimations([ 'simple_interact' ]);
  }
  
  // ... Other character controller logic
}

Run, walk and idle animations based on our WASD player inputs for movement.
One-shot Animations
One-shot animations are exactly what they sound like. An animation that plays only once. This is great for things like a gun-shooting effect when the player presses a button in game to fire a weapon, or a movement of a player's hand each time they click to interact with something, etc.

Let's assume our PlayerEntity model assigned to a player when they join a game has a dance animation, and a hand waving animation called wave. We'll play then as a one-shot when a player joins.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  const playerEntity = new PlayerEntity({
    player,
    name: 'Player',
    modelUri: 'models/my-player.gltf',
    modelLoopedAnimations: [ 'idle' ],
    modelScale: 0.5,
  });
  
  playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
  
  // Note: An entity must be spawned to start/stop animations,
  // otherwise the invoked animation methods will throw an error.
  
  // dance and wave animation is assumed to exist in the my-player.gltf
  // file. Both animations will play and blend together.
  playerEntity.startModelOneshotAnimations([ 'dance', 'wave' ]);
});
Animations & Entity Colliders
It's important to note that the animation state of model entities is entirely visual. Played animations will not automatically alter or move the collider(s) of an entity even if the entity is visually moving relative to it's collider because of the animation. 

If you need your collider to move along with the animation state played, you'll need to implement this manually with your own timings and logic to alter the translation and rotation of the entity collider(s) relative to the animation played.

Block Entities
Block entities are exactly what they sound like. A block, that behaves like an entity. This allows you to create blocks of any size that interact with the physical world. They can move, rotate, have impulses and velocities applied to them, and so much more.

Common Uses & Examples
Let's dive into some of the most common use cases of block entities.

Moving Platform
Probably the most common use, let's create a block entity that is a platform in the sky that moves at a constant speed in the +z/-z axis direction.

Copy
const blockPlatform = new Entity({
  blockTextureUri: 'blocks/grass', // A texture URI without a file extension will use a folder and look for the textures for each face in the folder (-x.png, +x.png, -y.png, +y.png, -z.png, +z.png)
  blockHalfExtents: { x: 1, y: 0.5, z: 1 },
  rigidBodyOptions: {
    type: RigidBodyType.KINEMATIC_VELOCITY, // Kinematic means platform won't be effected by external physics, including gravity
    linearVelocity: { x: 0, y: 0, z: 3 }, // A starting velocity that won't change because it's kinematic
  },
});

// Clamp the z range the platform moves back and forth between
blockPlatform.on(EntityEvent.TICK, () => {
  const position = blockPlatform.getTranslation();

  if (position.z < -9) {
    blockPlatform.setLinearVelocity({ x: 0, y: 0, z: 3 });
  }

  if (position.z > 8) {
    blockPlatform.setLinearVelocity({ x: 0, y: 0, z: -3 });
  }
});

blockPlatform.spawn(world, { x: 3, y: 3, z: -7 });
Pushable Block
A block that we can push is great for puzzles and other things.

Copy
// Block entity is dynamic by default, meaning it will 
// interact with external forces/physics, including gravity
const movableBlock = new Entity({
  blockTextureUri: 'blocks/sand.png',
  blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 }, 
});

// For the sake of demonstration, we can even
// have a callback when we push the block!
movableBlock.on(EntityEvent.ENTITY_COLLISION, ({ otherEntity, started }) => {
  if (started) {
    world.chatManager.sendBroadcastMessage('The sand block was pushed!');
  }
});

movableBlock.spawn(world, { x: -4, y: 10, z: -6 });
Pushable Block With Locked Rotations & Translations
Copy
const movableBlock = new Entity({
  blockTextureUri: 'blocks/sand.png',
  blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 }, 
  rigidBodyOptions: {
    type: RigidBodyType.DYNAMIC, // default
    // Disable all rotations
    enabledRotations: { x: false, y: false, z: false },
    // Disable X axis, only allowing
    // movement (translation) on the Y and Z axes
    enabledTranslations: { x: false, y: true, z: true }, 
  }
});

movableBlock.spawn(world, { x: -4, y: 10, z: -6 });
Teleporting Block
Perhaps we want to create a block that teleports to different coordinate every few seconds for a platforming game, here's how we can do that.

Copy
const teleportCoordinates = [
  { x: 1, y: 3, z: 2 },
  { x: 5, y: 7, z: -5 },
  { x: 3, y: 5, z: 0 },
];
const blockPlatform = new Entity({
  blockTextureUri: 'blocks/grass', // A texture URI without a file extension will use a folder and look for the textures for each face in the folder (-x.png, +x.png, -y.png, +y.png, -z.png, +z.png)
  blockHalfExtents: { x: 1, y: 0.5, z: 1 },
  rigidBodyOptions: {
    type: RigidBodyType.KINEMATIC_POSITION, // Kinematic means platform won't be effected by external physics, including gravity
  },
});

blockPlatform.spawn(world, teleportCoordinates[0]);

// Pick a random coordinate to teleport to every 5 seconds
setInterval(() => {
  const teleportIndex = Math.floor(Math.random() * teleportCoordinates.length);
  blockPlatform.setTranslation(teleportCoordinates[teleportIndex]);
}, 5000);
Heavy Pushable Block
Pushable blocks are fun, but what if we want a block that multiple entities would need to push to be able to easily move? We can do that by creating a block with a heavier mass.

Copy
const movableBlock = new Entity({
  blockTextureUri: 'blocks/sand.png',
  blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 }, 
  rigidBodyOptions: {
    type: RigidBodyType.DYNAMIC,
    // Higher number = harder to push, play with 
    // changing this for different results
    additionalMass: 10,
  }
});

movableBlock.spawn(world, { x: -4, y: 10, z: -6 });
Colliders & Hitbox
All entities by default will automatically calculate their own best-sized collider for their initial hitbox that represents them in the world.

For block entities, this collider is calculated on the provided blockHalfExtents. 

For model entities, this collider is calculated by an internal approximation based on the .gltf or .glb file of the entity and its modelScale .

Overriding Default Colliders & Aggro Sensor Example
You can override the default colliders for any entity by providing your own collider options to the rigidBodyOptions of the entity when creating an instance of it. You'll set the colliders property with an array of ColliderOptions objects.

Let's use custom colliders to do something a little more interesting, how about we add an aggro sensor to our spider?

Copy
let aggroPlayer: PlayerEntity | undefined;

const spider = new Entity({
  controller: new SimpleEntityController(),
  modelUri: 'models/npcs/spider.gltf',
  modelScale: 10,
  modelLoopedAnimations: [ 'idle' ],
  rigidBodyOptions: {
    colliders: [ // If we provide colliders, the default collider will not be created.
      Collider.optionsFromModelUri('models/uri/spider.gltf', 2),
      { // Create a sensor to detect players 
        shape: ColliderShape.CYLINDER,
        radius: 5,
        halfHeight: 2,
        isSensor: true, // This makes the collider not collide with other entities/objects, just sense their intersection
        tag: 'aggro-sensor',
        onCollision: (other: BlockType | Entity, started: boolean) => {
          if (started && other instanceof PlayerEntity) {
            aggroPlayer = other;
          }
        },
      },
    ]
  }
});

// Some chasing logic from our sensor collider that detects an aggro radius
// Now, when our player goes within the aggro sensor, the spider will 
// move towards them to "chase" them each tick.
spider.on(EntityEvent.TICK, () => {
  if (aggroPlayer) {
    // Chase the player
    (spider.controller as SimpleEntityController).move(aggroPlayer.position, 5);
    (spider.controller as SimpleEntityController).face(aggroPlayer.position, 3);
  }
});

spider.spawn(world, { x: 0, y: 5, z: 0 });
There's multiple ways to do this as well, one way may be better depending on your logical patterns, but performance is the same internally. 

Sometimes it's simpler to create your custom colliders when creating the instance of your entity. Other times, it might be easier to create some additional custom colliders at some point after creating the instance of your entity but before spawning it. 

One example where this would be useful is when a Entity Controller needs to attach custom colliders to the entity that becomes attached to it. You can see this is use in the Player Entity Controller guide. 

We can accomplish the  with our custom sensor collider in the following way as well.

Copy
let aggroPlayer: PlayerEntity | undefined;

const spider = new Entity({
  controller: new SimpleEntityController(),
  modelUri: 'models/uri/spider.gltf',
  modelScale: 10,
  modelLoopedAnimations: [ 'idle' ],
});

// Create a default approximated collider for the hitbox from the model
// This is the same way the default collider is created internally for an entity
// if no other colliders are specified.
spider.createAndAddChildCollider(Collider.optionsFromModelUri('models/uri/spider.gltf', 2));

// Add our sensor collider
spider.createAndAddChildCollider({
  shape: ColliderShape.CYLINDER,
  radius: 5,
  halfHeight: 2,
  isSensor: true, // This makes the collider not collide with other entities/objects, just sense their intersection
  tag: 'aggro-sensor',
  onCollision: (other: BlockType | Entity, started: boolean) => {
    if (started && other instanceof PlayerEntity) {
      aggroPlayer = other;
    }
  },
});

// Some chasing logic from our sensor collider that detects an aggro radius
// Now, when our player goes within th
spider.on(EntityEvent.TICK, () => {
  if (aggroPlayer) {
    // Chase the player
    (spider.controller as SimpleEntityController).move(aggroPlayer.position, 5);
    (spider.controller as SimpleEntityController).face(aggroPlayer.position, 3);
  }
});

spider.spawn(world, { x: 0, y: 5, z: 0 });
Now that's fun! Our spider chases us down as we run around!


Our spider chasing us by making use of our custom colliders for an aggro sensor.
Diving Deeper
Collider control is probably one of the most powerful unlocks in the HYTOPIA SDK, enabling you to create all sorts of interactions and behaviors for your entities relative to the physical world.

If you'd like to learn more about colliders, we recommend you dive deeper into the physics guides for the SDK, specifically Colliders.

Child Entities
Child entities are entities that are attached to a parent entity. Child entities are purely visual and cannot not have physical colliders.

You can use child entities to create visual attachments to any other entity. For example, you could attach a sword model to the hand of a player entity, attach the player entity to the top of a horse model as a mount, and so much more.

Existing entities can be attached as child entities at any time, or you can even spawn an entity as a child of another already spawned entity. Robust and flexible!

Child entities are supported for both Block Entities and Model Entities.


A horse entity with a player entity attached as a child, creating a "mount" look.
Limitations & Constraints Of Child Entities
Child entities inherit most of the behaviors of standard entities, however they do have a few limitations and constraints as follows.

Colliders are disabled - Colliders and physical collisions are not supported by child entities. They are purely visual. All colliders of an child entity will be disabled when attached to a parent. When a child is removed from it's parent entity and is therefore no longer a child entity, its colliders will automatically be re-enabled.

Parent Must Be Spawned First - The parent of a child entity must already be spawned before the a child's .spawn()is called. 

Isolated Kinematic Simulation - Child entities don't have colliders and therefore cannot collide or interact physically. They can however have forces, translations and rotations applied to them for visual simulations. Child entities will by default be created as a kinematic velocity based rigid body with no colliders.

Anchoring & Relative Movements
Child entities are always positioned and rotated relative to their parent. Their relative positioning and rotation will even stay consistent as the parent plays different animation states. Child entities are anchored to the center point of their parent model by default, or to a specific name model node of the parent if a parentNodeNameis provided in the child entities options when creating it.

For example, if you anchor a sword model as a child entity to the hand of a player model, and then trigger an animation that makes the player's arm swing, the sword will fluidly swing as you'd expect because it is attached to the model node that is part of the animation.

This relative anchoring, positioning and rotation is always constant for models in the HYTOPIA engine, even children that are children of another child entity.

Creating A Child Entity
Let's start with a practical example. Let's say we're building an RPG and want to attach a visual sword to our character's hand.

We can use the parentand parentNodeName options when creating our sword entity to attach it to our player entity's hand.

This is super simple with using a child entity like so.

Copy
const playerEntity = new PlayerEntity({
  player,
  name: 'Player',
  modelUri: 'models/players/player.gltf',
  modelLoopedAnimations: [ 'idle' ],
  modelScale: 0.5,
});

// The parent, which is the player entity, must be spawned
// before the sword is spawned.
playerEntity.spawn(world, { x: 0, y: 10, z: 0 });

const swordChildEntity = new Entity({
  name: 'sword',
  modelUri: 'models/items/sword.gltf',
  parent: playerEntity,
  parentNodeName: 'hand_right_anchor', // attach it to the hand node of our parent model
});

swordChildEntity.spawn(
  world,
  { x: 0, y: 0.3, z: 0.5 }, // spawn with a position relative to the parent node
  { x: -Math.PI / 3, y: 0, z: 0, w: 1 } // spawn with a rotation
);
That's it! Our player is now holding a sword, and the sword will move appropriately and stay anchored with all our parent entities animations too!


Nested Child Entities
You can go a step farther if needed and nest an entity as a child of another child entity. Depth nesting is supporting to any depth desired, however it's not recommend to do excessive child nesting as it could impact gameplay performance for players. For example, try not to nest like (Player Entity -> child -> child -> child -> ... etc)

If you want to use child nesting, here's an example of how you can do that. Maybe we want our sword to have a fish spiked onto the end of it.

Copy
const playerEntity = new PlayerEntity({
  player,
  name: 'Player',
  modelUri: 'models/players/player.gltf',
  modelLoopedAnimations: [ 'idle' ],
  modelScale: 0.5,
});

// The parent, which is the player entity, must be spawned
// before the sword is spawned.
playerEntity.spawn(world, { x: 0, y: 10, z: 0 });

const swordChildEntity = new Entity({
  name: 'sword',
  modelUri: 'models/items/sword.gltf', // you might not have this model by default
  parent: playerEntity,
  parentNodeName: 'hand_right_anchor', // attach it to the hand node of our parent model
});

swordChildEntity.spawn(
  world,
  { x: 0, y: 0.3, z: 0.5 }, // spawn with a position relative to the parent node
  { x: -Math.PI / 3, y: 0, z: 0, w: 1 } // spawn with a rotation
);

// Everything above this is the same code from our previous example.

// Create our fish as a child of our sword
const fishChildEntity = new Entity({
  name: 'fish',
  modelUri: 'models/items/fish.gltf', // you might now have this model by default.
  modelScale: 2,
  parent: swordChildEntity,
});
    
fishChildEntity.spawn(world, { x: 0, y: 1, z: 0.5 });
Wallah! We have a fish model that looks like it's staked on the end of our sword!


A fish model that is a child of our sword, positioned relatively to look like it's staked on our sword!
Attaching & Detaching An Existing Entity As A Child
You can attach and detach entities as children as much as you'd like. This is useful for a lot of things like picking up held items, weapons, making a player attach to a mount entity, and much more. This also means you don't need to do any dynamic spawning and despawning of child and parent entities when dealing with attachments, everything stays simple and easy!

In this example, let's create a sword and when a player collides with it, we'll attach it as a child entity in the player's hand. After 5 seconds, the sword will detach and fly away in front of the player.

This example makes use of the setParent()function of the Entity class. This method is quite powerful and is worth taking a look at the documentation for, here.

Copy
const swordEntity = new Entity({
  name: 'Sword',
  modelUri: 'models/items/sword.gltf',
});

swordEntity.on(EntityEvent.ENTITY_COLLISION, ({ otherEntity, started }) => {
  if (started && otherEntity instanceof PlayerEntity) {
    swordEntity.setParent(otherEntity, 'hand_right_anchor', { x: 0, y: 0.2, z: 0.4 }, Quaternion.fromEuler(-90, 0, 0));
      
    setTimeout(() => {
      const facingDirection = otherEntity.directionFromRotation;
      const playerPosition = otherEntity.position;
      swordEntity.setParent(undefined, undefined, { 
        x: playerPosition.x + -facingDirection.x * 2, 
        y: playerPosition.y + 1, 
        z: playerPosition.z + -facingDirection.z * 2,
      });
      swordEntity.setLinearVelocity({ x: -facingDirection.x * 10, y: 10, z: -facingDirection.z * 10 });
    }, 5000);
  }
});

swordEntity.spawn(world, { x: 3, y: 10, z: 3 });
This results in the following! Also! If we were to touch the sword again after it was thrown, we'd pick it up again and the same throw effect after 5 seconds would happen as well.


Applying Local Forces & Physics
Child entities do not and cannot participate in physical collisions. They cannot have colliders. However, most of the methods available to a standard entity work just the same on a child entity for manipulating its visual position and rotation by setting position, rotation, or applying forces.

For example, child entities are the equivalent of kinematic rigid body. Therefore, we do things like apply  velocities and forces that locally effect the child. 

Here's how you can use these local forces for interesting visual effects like creating a hat that constantly rotates by using angular velocity.

Copy
const hatEntity = new Entity({
  name: 'wizardHat',
  modelUri: 'models/pumpkinhead.gltf',
  parent: playerEntity,
  parentNodeName: 'neck',
  rigidBodyOptions: {
    // Angular velocity is constant because external
    // physical forces do not effect children since
    // child entities are kinematic rigid bodies.
    angularVelocity: { x: 0, y: 1, z: 0 },
  },
});

hatEntity.spawn(world, { x: 0, y: 0.8, z: 0 }); // position relative to parent node
Here's our rotating pumpkin hat!


A rotating pumpkin hat that stays anchored to our player even as it animates and moves.
Listing Model Nodes
Sometimes you may be unsure of what available nodes a model has to attach to. Thankfully, we can use the ModelRegistry class in the SDK to get a full list of all known named nodes that a child entity can be attached to for a parent model entity.

Copy
console.log(ModelRegistry.instance.getNodeNames('models/items/sword.gltf'));
This console.log anywhere in our code will log an array of unique available node names for the model URI we provide.

Default Player Entity Anchor Nodes
Attaching children to different anchor points on the default player entity is extremely common. For example, you may want to attach a child sword entity to the hand of the default player entity model (player.gltf). You would attach it there by providing the appropriate anchor node name for the parentNodeName property in the child entity's options.

For convenience sake, we've provided a table below of the different anchor point node names the default player entity has.

Anchor Node Name
Purpose
arm_left_anchor

Left arm anchor

arm_right_anchor

Right arm anchor

back_anchor

Back anchor, useful for backpacks, etc

foot_left_anchor

Left foot anchor

foot_right_anchor

Right foor anchor

hand_left_anchor

Left hand anchor

hand_left_shield_anchor

Left hand shield anchor, positions on the outer of the left hand.

hand_right_anchor

Right hand anchor

hand_right_weapon_anchor

Right hand weapon anchor, positions relative to a held position in the hand for a weapon.

head_anchor

Head anchor

leg_left_anchor

Left leg anchor

leg_right_anchor

Right leg anchor

torso_anchor

Torso anchor, anchors at chest.

Diving Deeper
The child entity system is constantly evolving. It is a part of the Entity class, you can find the latest Entity API Reference here.

If there are features that we don't currently support for child entities that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Entity Controllers
Entity controllers are the brains behind an entity. They enable you to physically define how an entity is controlled or interacts with the world. Entity controllers often handle things like entity movement logic, entity movement related state, pathfinding, AI behavior, and many other things.

All control related logic of an entity is suited to be included in an entity controller.

Lifecycle Overview
All entity controllers inherit from the BaseEntityController class. This class defines the lifecycle methods an entity controller has and can override.

The lifecycle of an entity controller is based on the following order.

Attach - the attach()method of the controller is called when it is attached to an entity. This is where you can do initialization or additional collider assignments to the attached entity if necessary depending on what you need your entity controller to do.

Spawn - the spawn()method of the controller is called when the entity first spawns. If the attached entity is already spawned, this will not be called.

TickWithPlayerInput - If the controller is attached to an entity that is an instance of the PlayerEntity class, or a class that extends it, tickWithPlayerInput() will be called with the controlling players current input.

Tick - the tick() method of the controller is called each tick while the entity is still spawned.

Detach - the detach() method of the controller is called when the controller is detached from the entity. This is also called right before the entity is despawned from entity.despawn().

Despawn - the despawn()method of the controller is called when the entity despawns.

Premade Entity Controllers
The HYTOPIA SDK currently provides 2 premade entity controllers out of the box that work great for simple needs, or as a foundation to build your own game-specific entity controllers on top of.

Player Entity Controller - The default controller automatically assigned to a PlayerEntityif your own entity controller is not provided. This controller handles basic movement behaviors like WASD movement, jump, camera movement, platform sticking, and more.

Simple Entity Controller - A "simple" entity controller that implements basic quality of life controls like .move()and .face(), allowing you to create basic or complex pathfinding based on target coordinates and movement speeds without needing to do any additional complex math for movements. Completion callbacks are also supported for both methods this entity controller exposes.

Next Steps
Entity controllers are a core concept when creating any type of custom movement, npc or AI behaviors for your game. You can dive deeper into the different types of entity controllers to learn more.

Base Entity Controller

Learn more about the BaseEntityController class and methods it exposes for controller lifecycles.

Player Entity Controller

Learn more about the PlayerEntityController class for manipulating entity behaviors based on player inputs.

Simple Entity Controller

Learn more about the SimpleEntityController class for creating pathfinding and movement behaviors.

Base Entity Controller
The BaseEntityController class is what all other types of entity controllers inherit from.

Below is the SDK's internal implementation of the BaseEntityController for reference, giving direct insight into how it works.

Copy
/**
 * A base class for entity controller implementations.
 * 
 * @remarks
 * The BaseEntityController should be extended 
 * by a more specific entity controller that you or a
 * plugin implements. Entity controllers are intended to
 * be used as one controller instance per entity, but
 * are flexible enough for edge cases such as if you want to create
 * niche behavior of one controller for many entities that
 * behave in unison.
 * 
 * <h2>Events</h2>
 * 
 * This class is an EventRouter, and instances of it emit
 * events with payloads listed under {@link BaseEntityControllerEventPayloads}
 * 
 * @public
 */
export default abstract class BaseEntityController extends EventRouter {
  /**
   * Override this method to handle the attachment of an entity
   * to your entity controller.
   * @param entity - The entity to attach the controller to.
   */
  public attach(entity: Entity): void {
    this.emit(BaseEntityControllerEvent.ATTACH, { entity });
  };

  /**
   * Override this method to handle the despawn of an entity
   * from your entity controller.
   * @param entity - The entity to despawn.
   */
  public despawn(entity: Entity): void {
    this.emit(BaseEntityControllerEvent.DESPAWN, { entity });
  };

  
  /**
   * Override this method to handle the detachment of an entity
   * from your entity controller.
   * @param entity - The entity to detach.
   */
  public detach(entity: Entity): void {
    this.emit(BaseEntityControllerEvent.DETACH, { entity });
  };
  
  /**
   * Override this method to handle the spawning of an entity
   * to your entity controller.
   * @param entity - The entity to spawn.
   */
  public spawn(entity: Entity): void {
    this.emit(BaseEntityControllerEvent.SPAWN, { entity });
  };

  /**
   * Override this method to handle entity movements
   * based on player input for your entity controller.
   * This is called every tick by a PlayerEntity with a
   * entity controller.
   * @param entity - The entity to tick.
   * @param input - The current input state of the player.
   * @param cameraOrientation - The current camera orientation state of the player.
   * @param deltaTimeMs - The delta time in milliseconds since the last tick.
   */
  public tickWithPlayerInput(entity: PlayerEntity, input: PlayerInput, cameraOrientation: PlayerCameraOrientation, deltaTimeMs: number): void {
    this.emit(BaseEntityControllerEvent.TICK_WITH_PLAYER_INPUT, { entity, input, cameraOrientation, deltaTimeMs });
  }

  /**
   * Override this method to handle entity movements
   * based on your entity controller.
   * @param deltaTimeMs - The delta time in milliseconds since the last tick.
   */
  public tick(entity: Entity, deltaTimeMs: number): void {
    this.emit(BaseEntityControllerEvent.TICK, { entity, deltaTimeMs });
  }
}
Diving Deeper
The BaseEntityController class is constantly evolving. You can find the latest BaseEntityController API Reference here.

If there are features that we don't currently support for the BaseEntityController that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Pathfinding Entity Controller
The PathfindingEntityController class extends the SimpleEntityController to implement a hybrid A* algorithm for optimal pathfinding.

Below is the SDK's internal implementation of the PathfindingEntityController for reference, giving direct insight into how it works.

Copy
/**
 * A pathfinding entity controller built on top of {@link SimpleEntityController}.
 * 
 * @remarks
 * This class implements pathfinding using the A* algorithm. Pathfinding when frequently
 * called can cause performance issues, use it sparingly. The .pathfind() method should only need to
 * be called once in nearly all cases when attempting to move an entity to a target coordinate.
 * 
 * @public
 */
export default class PathfindingEntityController extends SimpleEntityController {
  /** @internal */
  private _debug: boolean = false;

  /** @internal */
  private _entity: Entity | undefined;

  /** @internal */
  private _maxFall: number = 0;

  /** @internal */
  private _maxJump: number = 0;

  /** @internal */
  private _maxOpenSetIterations: number = 200;

  /** @internal */
  private _onPathfindAbort: PathfindAbortCallback | undefined;

  /** @internal */
  private _onPathfindComplete: PathfindCompleteCallback | undefined;

  /** @internal */
  private _onWaypointMoveComplete: WaypointMoveCompleteCallback | undefined;

  /** @internal */
  private _onWaypointMoveSkipped: WaypointMoveSkippedCallback | undefined;

  /** @internal */
  private _speed: number = 0;

  /** @internal */
  private _target: Vector3Like | undefined;

  /** @internal */
  private _verticalPenalty: number = 0;

  /** @internal */
  private _waypoints: Vector3Like[] = [];

  /** @internal */
  private _waypointNextIndex: number = 0;

  /** @internal */
  private _waypointTimeoutMs: number = 2000;

  /** Whether to enable debug mode or not. When debug mode is enabled, the pathfinding algorithm will log debug information to the console. Defaults to false. */
  public get debug(): boolean { return this._debug; }
  
  /** The maximum fall distance the entity can fall. */
  public get maxFall(): number { return this._maxFall; }

  /** The maximum jump distance the entity can jump. */
  public get maxJump(): number { return this._maxJump; }

  /** The maximum number of open set iterations that can be processed before aborting pathfinding. Defaults to 200. */
  public get maxOpenSetIterations(): number { return this._maxOpenSetIterations; }

  /** The speed of the entity. */
  public get speed(): number { return this._speed; }

  /** The target coordinate to pathfind to. */
  public get target(): Vector3Like | undefined { return this._target; }

  /** The vertical penalty for the pathfinding algorithm. A higher value will prefer paths with less vertical movement. */
  public get verticalPenalty(): number { return this._verticalPenalty; }

  /** The current waypoints being followed. */
  public get waypoints(): Vector3Like[] { return this._waypoints; }

  /** The index representing the next waypoint moving towards of the current set of waypoints being followed. */
  public get waypointNextIndex(): number { return this._waypointNextIndex; }

  /** The timeout in milliseconds for a waypoint to be considered reached. Defaults to 2000ms divided by the speed of the entity. */
  public get waypointTimeoutMs(): number { return this._waypointTimeoutMs; }

  /**
   * Calculate a path and move to the target if a path is found. Returns true if a path is found, false if no path is found.
   * @param target - The target coordinate to pathfind to.
   * @param speed - The speed of the entity.
   * @param options - The pathfinding options.
   * @returns Whether the path was found.
   */
  public pathfind(target: Vector3Like, speed: number, options?: PathfindingOptions): boolean {
    this._target = target;
    this._speed = speed;
    this._debug = options?.debug ?? false;
    this._maxFall = options?.maxFall ? -Math.abs(options.maxFall) : 0; // negative fall distance
    this._maxJump = options?.maxJump ? Math.abs(options.maxJump) : 0;  // positive jump distance
    this._maxOpenSetIterations = options?.maxOpenSetIterations ?? 200;
    this._onPathfindAbort = options?.pathfindAbortCallback;
    this._onPathfindComplete = options?.pathfindCompleteCallback;
    this._onWaypointMoveComplete = options?.waypointMoveCompleteCallback;
    this._onWaypointMoveSkipped = options?.waypointMoveSkippedCallback;
    this._verticalPenalty = options?.verticalPenalty ?? 0;
    this._waypoints = [];
    this._waypointNextIndex = 0;
    this._waypointTimeoutMs = options?.waypointTimeoutMs ?? 2000 / speed;
    
    if (!this._calculatePath()) {
      return false;
    }

    this._moveToNextWaypoint();

    return true;
  }

  /** @internal */
  public override attach(entity: Entity): void {
    super.attach(entity);
    this._entity = entity;
  }

  /** @internal */
  public override detach(entity: Entity): void {
    super.detach(entity);
    this._entity = undefined;
  }

  /** @internal */
  public override tick(entity: Entity, deltaTimeMs: number): void {
    super.tick(entity, deltaTimeMs);
  }

  /** @internal */
  private _calculatePath(): boolean {
    if (!this._target || !this._entity?.world) {
      throw new Error('PathfindingEntityController._calculatePath: No target or world');
    }

    const entityHeight = this._entity.height;

    const start = this._findGroundedStart();

    if (!start) {
      if (this._debug) {
        console.warn(`PathfindingEntityController._calculatePath: No valid grounded start found within maxFall distance, path search aborted. Start: ${this._coordinateToKey(this._target)}, Target: ${this._coordinateToKey(this._target)}`);
      }

      return false;
    }

    const end = {
      x: Math.floor(this._target.x),
      y: Math.floor(this._target.y),
      z: Math.floor(this._target.z),
    };

    // Quick check for direct path if target is close
    const dx = Math.abs(end.x - start.x);
    const dy = Math.abs(end.y - start.y);
    const dz = Math.abs(end.z - start.z);
    const isClose = dx <= 2 && dy <= 2 && dz <= 2;

    if (isClose && !this._isNeighborCoordinateBlocked(start, end, this._entity.height)) {
      this._waypoints = [
        { x: start.x + 0.5, y: start.y + entityHeight / 2, z: start.z + 0.5 },
        { x: end.x + 0.5, y: end.y + entityHeight / 2, z: end.z + 0.5 },
      ];

      return true;
    }

    // Return if start is already at the end
    if (start.x === end.x && start.y === end.y && start.z === end.z) {
      this._waypoints = [ { x: start.x + 0.5, y: start.y + entityHeight / 2, z: start.z + 0.5 } ];

      return true;
    }

    // A* data structures using binary heap for open set
    const startKey = this._coordinateToKey(start);
    const cameFrom = new Map<string, Vector3Like>();
    const gScore = new Map<string, number>([ [ startKey, 0 ] ]);
    const fScore = new Map<string, number>([ [ startKey, this._pathfindingHeuristic(start, end) ] ]);
    const closedSet = new Set<string>();

    // Binary heap implementation for open set
    const openSet = new Heap<[string, Vector3Like]>((a, b) => {
      const aScore = fScore.get(a[0]) ?? Infinity;
      const bScore = fScore.get(b[0]) ?? Infinity;

      return aScore - bScore;
    });

    openSet.push([ startKey, start ]);

    // Pre-calculate neighbor offsets for pathfinding
    const horizontalOffsets: Vector3Like[] = [
      // Prioritize cardinal directions first
      { x: 0, y: 0, z: 1 }, { x: 1, y: 0, z: 0 },
      { x: 0, y: 0, z: -1 }, { x: -1, y: 0, z: 0 },
      // Then diagonals
      { x: 1, y: 0, z: 1 }, { x: 1, y: 0, z: -1 },
      { x: -1, y: 0, z: 1 }, { x: -1, y: 0, z: -1 },
    ];

    // Sort vertical offsets by distance to target's y-level
    const verticalOffsets = [];
    for (let y = this._maxJump; y >= this._maxFall; y--) {
      if (y === 0) continue;
      const distanceToTargetY = Math.abs((start.y + y) - end.y);
      verticalOffsets.push({ y, distanceToTargetY });
    }
    verticalOffsets.sort((a, b) => a.distanceToTargetY - b.distanceToTargetY);

    const neighborOffsets: Vector3Like[] = [
      ...horizontalOffsets,
      ...verticalOffsets.flatMap(({ y }) => 
        horizontalOffsets.map(offset => ({ ...offset, y })),
      ),
    ];

    let openSetIterations = 0;
    const maxDistance = Math.abs(end.x - start.x) + Math.abs(end.y - start.y) + Math.abs(end.z - start.z);
    const iterationLimit = Math.min(this._maxOpenSetIterations, maxDistance * 20);

    while (!openSet.isEmpty() && openSetIterations < iterationLimit) {
      openSetIterations++;

      const [ currentKey, current ] = openSet.pop()!;

      // Check if we reached the end
      if (current.x === end.x && current.y === end.y && current.z === end.z) {
        const path = this._reconstructPath(cameFrom, current);
        this._waypoints = path.map(p => ({
          x: p.x + 0.5,
          y: p.y + entityHeight / 2,
          z: p.z + 0.5,
        }));

        if (this._debug) {
          console.log(`PathfindingEntityController._calculatePath: Path found after ${openSetIterations} open set iterations. Start: ${this._coordinateToKey(start)}, Target: ${this._coordinateToKey(this._target)}`);
        }

        return true;
      }

      closedSet.add(currentKey);
      const currGScore = gScore.get(currentKey)!;
      const xzOffsetFloorBlocked = new Map<string, boolean>();

      for (const offset of neighborOffsets) {
        const xzOffsetKey = `${offset.x},${offset.z}`;
        const requiresFalling = offset.y < 0;
        
        if (requiresFalling && xzOffsetFloorBlocked.has(xzOffsetKey)) {
          continue;
        }

        const neighbor = {
          x: current.x + offset.x,
          y: current.y + offset.y,
          z: current.z + offset.z,
        };

        // Early distance check
        const manhattanToEnd = Math.abs(end.x - neighbor.x) + Math.abs(end.y - neighbor.y) + Math.abs(end.z - neighbor.z);
        if (manhattanToEnd > maxDistance * 1.5) {
          continue;
        }

        const neighborKey = this._coordinateToKey(neighbor);
        
        if (closedSet.has(neighborKey)) {
          continue;
        }

        const blocked = this._isNeighborCoordinateBlocked(current, neighbor, this._entity.height);

        if (requiresFalling && blocked) {
          xzOffsetFloorBlocked.set(xzOffsetKey, true);
          continue;
        }

        if (blocked) {
          continue;
        }

        const dx = Math.abs(offset.x);
        const dy = Math.abs(offset.y);
        const dz = Math.abs(offset.z);
        const verticalPenalty = dy === 0 ? 0 : this._verticalPenalty;
        const distance = (Math.max(dx, dy, dz) === 1 && (dx + dy + dz) > 1 ? 1.4 : 1) + verticalPenalty;
        const tentativeGScore = currGScore + distance;

        const existingGScore = gScore.get(neighborKey) ?? Infinity;
        if (tentativeGScore >= existingGScore) {
          continue;
        }

        cameFrom.set(neighborKey, current);
        gScore.set(neighborKey, tentativeGScore);
        const f = tentativeGScore + this._pathfindingHeuristic(neighbor, end);
        fScore.set(neighborKey, f);
        openSet.push([ neighborKey, neighbor ]);
      }
    }

    if (openSetIterations >= iterationLimit) {
      this._onPathfindAbort?.();
      if (this._debug) {
        console.warn(`PathfindingEntityController._calculatePath: Maximum open set iterations reached (${iterationLimit}), path search aborted. Start: ${this._coordinateToKey(start)}, Target: ${this._coordinateToKey(this._target)}`);
      }
    } else if (this._debug) {
      console.warn(`PathfindingEntityController._calculatePath: No valid path found. Start: ${this._coordinateToKey(start)}, Target: ${this._coordinateToKey(this._target)}`);
    }
    
    this._target = undefined;
    this._waypoints = [];

    return false;
  }

  /** @internal */
  private _reconstructPath(cameFrom: Map<string, Vector3Like>, current: Vector3Like): Vector3Like[] {
    const path: Vector3Like[] = [ current ];
    let curr = current;
    
    while (cameFrom.has(this._coordinateToKey(curr))) {
      curr = cameFrom.get(this._coordinateToKey(curr))!;
      path.unshift(curr);
    }

    return path;
  }

  /** @internal */
  private _coordinateToKey(coordinate: Vector3Like): string {
    return `${coordinate.x},${coordinate.y},${coordinate.z}`;
  }

  /** @internal */
  private _moveToNextWaypoint(): void {
    const currentWaypoint = this._waypointNextIndex > 0 ? this._waypoints[this._waypointNextIndex - 1] : undefined;
    const nextWaypoint = this._waypoints[this._waypointNextIndex];

    if (!nextWaypoint || !this._entity) {
      return;
    }

    // Jump if the next waypoint is higher than the current waypoint
    let jumpTimeout = 0;
    if (this._entity.isDynamic && currentWaypoint && nextWaypoint.y > currentWaypoint.y) {
      const height = nextWaypoint.y - currentWaypoint.y;
      const jumpHeight = Math.min(height, this._maxJump) + 0.75;
      this.jump(jumpHeight);

      const gravity = Math.abs(this._entity.world!.simulation.gravity.y);
      const initialVelocity = Math.sqrt(2 * gravity * jumpHeight);
      
      // Calculate horizontal distance to travel, accounting for entity being at center of block
      const currentCenterX = currentWaypoint.x + 0.5;
      const currentCenterZ = currentWaypoint.z + 0.5;
      const nextCenterX = nextWaypoint.x + 0.5;
      const nextCenterZ = nextWaypoint.z + 0.5;
      
      const dx = nextCenterX - currentCenterX;
      const dz = nextCenterZ - currentCenterZ;
      const horizontalDistance = Math.sqrt(dx * dx + dz * dz);
      
      // Time to reach peak height = initialVelocity / gravity
      // Time to travel horizontal distance = horizontalDistance / speed
      // We want to start moving slightly before reaching peak height
      const timeToApex = initialVelocity / gravity;
      const timeToTravel = horizontalDistance / this._speed;
      const moveDelay = Math.min(timeToApex * 0.8, timeToTravel) * 1000; // Convert to ms
      jumpTimeout = moveDelay;
    }

    // Wait for jump to complete before moving to next waypoint
    setTimeout(() => {
      if (!this._entity) {
        return;
      }

      const lastMoveTime = Date.now();

      this.face(nextWaypoint, this._speed);
      this.move(nextWaypoint, this._speed, {
        moveIgnoreAxes: { y: this._entity.isDynamic },
        moveCallback: () => {
          if (Date.now() - lastMoveTime > this._waypointTimeoutMs && this._waypointNextIndex < this._waypoints.length - 1) {
            this._onWaypointMoveSkipped?.(nextWaypoint, this._waypointNextIndex);
            this._waypointNextIndex++;
            this._moveToNextWaypoint();
          }
        },
        moveCompleteCallback: () => {
          if (this._waypointNextIndex < this._waypoints.length - 1) {
            this._onWaypointMoveComplete?.(nextWaypoint, this._waypointNextIndex);
            this._waypointNextIndex++;
            this._moveToNextWaypoint();
          } else {
            this._onPathfindComplete?.();
          }
        },
      });
    }, jumpTimeout);
  }

  /** @internal */
  private _pathfindingHeuristic(a: Vector3Like, b: Vector3Like) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y) + Math.abs(a.z - b.z);
  }

  /** @internal */
  private _isNeighborCoordinateBlocked(currentCoordinate: Vector3Like, neighborCoordinate: Vector3Like, entityHeight: number) {
    if (!this._entity?.world) {
      return false;
    }
    
    const world = this._entity.world;
    const x = Math.floor(neighborCoordinate.x);
    const y = Math.floor(neighborCoordinate.y);
    const z = Math.floor(neighborCoordinate.z);
    const currentX = Math.floor(currentCoordinate.x);
    const currentZ = Math.floor(currentCoordinate.z);

    // Check for ground to walk on & prevent pathfinding by going up and walking on air
    if (!world.chunkLattice.hasBlock({ x, y: y - 1, z })) { 
      return true;
    }

    // Check for blocks that the entity would collide with based on its height
    for (let i = 0; i < entityHeight; i++) {
      if (world.chunkLattice.hasBlock({ x, y: y + i, z })) {
        return true;
      }
    }

    // Check diagonal movement
    if (x !== currentX && z !== currentZ) {
      // Check blocks perpendicular to movement direction & at entity height
      for (let i = 0; i < entityHeight; i++) {
        const hasBlockXAtHeight = world.chunkLattice.hasBlock({ x, y: y + i, z: currentZ });
        const hasBlockZAtHeight = world.chunkLattice.hasBlock({ x: currentX, y: y + i, z });
        if (hasBlockXAtHeight || hasBlockZAtHeight) {
          return true;
        }
      }
    }

    // No blockers!
    return false;
  }

  /** @internal */
  private _findGroundedStart(): Vector3Like | undefined {
    if (!this._entity?.world) {
      return;
    }

    const { x, y, z } = this._entity.position;
    const start = { x: Math.floor(x), y: Math.floor(y), z: Math.floor(z) };

    for (let dy = 0; dy <= Math.abs(this._maxFall); dy++) {
      if (this._entity.world.chunkLattice.hasBlock({ ...start, y: start.y - dy - 1 })) {
        return { ...start, y: start.y - dy };
      }
    }

    return;
  }
}
Player Entity Controller
The PlayerEntityController class is responsible for the default player movement controls of a PlayerEntity in HYTOPIA.

The PlayerEntityController is automatically assigned as the controller of a new PlayerEntity instances anytime one is created if you do not provide your own entity controller.

The current implementation of the SDK's internal PlayerEntityController can be found for reference below.

Copy
/** Options for creating a PlayerEntityController instance. @public */
export interface PlayerEntityControllerOptions {
  /** A function allowing custom logic to determine if the entity can jump. */
  canJump?: () => boolean;

  /** A function allowing custom logic to determine if the entity can walk. */
  canWalk?: () => boolean;

  /** A function allowing custom logic to determine if the entity can run. */
  canRun?: () => boolean;

  /** The upward velocity applied to the entity when it jumps. */
  jumpVelocity?: number;

  /** The normalized horizontal velocity applied to the entity when it runs. */
  runVelocity?: number;

  /** Whether the entity sticks to platforms, defaults to true. */
  sticksToPlatforms?: boolean;

  /** The normalized horizontal velocity applied to the entity when it walks. */
  walkVelocity?: number;
}

/**
 * The player entity controller implementation.
 * 
 * @remarks
 * This class extends {@link BaseEntityController}
 * and implements the default movement logic for a
 * entity. This is used as the default for
 * players when they join your game. This class may be extended
 * if you'd like to implement additional logic on top of the
 * PlayerEntityController implementation.
 * 
 * @example 
 * ```typescript
 * // Create a custom entity controller for myEntity, prior to spawning it.
 * myEntity.setController(new PlayerEntityController(myEntity, {
 *   jumpVelocity: 10,
 *   runVelocity: 8,
 *   walkVelocity: 4,
 * }));
 * 
 * // Spawn the entity in the world.
 * myEntity.spawn(world, { x: 53, y: 10, z: 23 });
 * ```
 * 
 * @public
 */
export default class PlayerEntityController extends BaseEntityController {
  /**
   * A function allowing custom logic to determine if the entity can walk.
   * @param playerEntityController - The entity controller instance.
   * @returns Whether the entity of the entity controller can walk.
   */
  public canWalk: (playerEntityController: PlayerEntityController) => boolean = () => true;

  /**
   * A function allowing custom logic to determine if the entity can run.
   * @param playerEntityController - The entity controller instance.
   * @returns Whether the entity of the entity controller can run.
   */
  public canRun: (playerEntityController: PlayerEntityController) => boolean = () => true;

  /**
   * A function allowing custom logic to determine if the entity can jump.
   * @param playerEntityController - The entity controller instance.
   * @returns Whether the entity of the entity controller can jump.
   */
  public canJump: (playerEntityController: PlayerEntityController) => boolean = () => true;

  /** The upward velocity applied to the entity when it jumps. */
  public jumpVelocity: number = 10;

  /** The normalized horizontal velocity applied to the entity when it runs. */
  public runVelocity: number = 8;

  /** Whether the entity sticks to platforms. */
  public sticksToPlatforms: boolean = true;

  /** The normalized horizontal velocity applied to the entity when it walks. */
  public walkVelocity: number = 4;

  /** @internal */
  private _stepAudio: Audio | undefined;

  /** @internal */
  private _groundContactCount: number = 0;

  /** @internal */
  private _platform: Entity | undefined;

  /**
   * @param options - Options for the controller.
   */
  public constructor(options: PlayerEntityControllerOptions = {}) {
    super();

    this.jumpVelocity = options.jumpVelocity ?? this.jumpVelocity;
    this.runVelocity = options.runVelocity ?? this.runVelocity;
    this.walkVelocity = options.walkVelocity ?? this.walkVelocity;
    this.canWalk = options.canWalk ?? this.canWalk;
    this.canRun = options.canRun ?? this.canRun;
    this.canJump = options.canJump ?? this.canJump;
    this.sticksToPlatforms = options.sticksToPlatforms ?? this.sticksToPlatforms;
  }

  /** Whether the entity is grounded. */
  public get isGrounded(): boolean { return this._groundContactCount > 0; }

  /** Whether the entity is on a platform, a platform is any entity with a kinematic rigid body. */
  public get isOnPlatform(): boolean { return !!this._platform; }

  /** The platform the entity is on, if any. */
  public get platform(): Entity | undefined { return this._platform; }

  /**
   * Called when the controller is attached to an entity.
   * @param entity - The entity to attach the controller to.
   */
  public attach(entity: Entity) {
    this._stepAudio = new Audio({
      uri: 'audio/sfx/step/stone/stone-step-04.mp3',
      loop: true,
      volume: 0.1,
      attachedToEntity: entity,
    });

    entity.lockAllRotations(); // prevent physics from applying rotation to the entity, we can still explicitly set it.
  };

  /**
   * Called when the controlled entity is spawned.
   * In PlayerEntityController, this function is used to create
   * the colliders for the entity for wall and ground detection.
   * @param entity - The entity that is spawned.
   */
  public spawn(entity: Entity) {
    if (!entity.isSpawned) {
      throw new Error('PlayerEntityController.createColliders(): Entity is not spawned!');
    }

    // Ground sensor
    entity.createAndAddChildCollider({
      shape: ColliderShape.CYLINDER,
      radius: 0.23,
      halfHeight: 0.125,
      collisionGroups: {
        belongsTo: [ CollisionGroup.ENTITY_SENSOR ],
        collidesWith: [ CollisionGroup.BLOCK, CollisionGroup.ENTITY ],
      },
      isSensor: true,
      relativePosition: { x: 0, y: -0.75, z: 0 },
      tag: 'groundSensor',
      onCollision: (_other: BlockType | Entity, started: boolean) => {
        // Ground contact
        this._groundContactCount += started ? 1 : -1;
  
        if (!this._groundContactCount) {
          entity.startModelOneshotAnimations([ 'jump_loop' ]);
        } else {
          entity.stopModelAnimations([ 'jump_loop' ]);
        }

        // Platform contact
        if (!(_other instanceof Entity) || !_other.isKinematic) return;
        
        if (started && this.sticksToPlatforms) {
          this._platform = _other;
        } else if (_other === this._platform && !started) {
          this._platform = undefined;
        }
      },
    });


    // Wall collider
    entity.createAndAddChildCollider({
      shape: ColliderShape.CAPSULE,
      halfHeight: 0.31,
      radius: 0.38,
      collisionGroups: {
        belongsTo: [ CollisionGroup.ENTITY_SENSOR ],
        collidesWith: [ CollisionGroup.BLOCK, CollisionGroup.ENTITY ],
      },
      friction: 0,
      frictionCombineRule: CoefficientCombineRule.Min,
      tag: 'wallCollider',
    });
  };

  /**
   * Ticks the player movement for the entity controller,
   * overriding the default implementation.
   * 
   * @param entity - The entity to tick.
   * @param input - The current input state of the player.
   * @param cameraOrientation - The current camera orientation state of the player.
   * @param deltaTimeMs - The delta time in milliseconds since the last tick.
   */
  public tickWithPlayerInput(entity: PlayerEntity, input: PlayerInput, cameraOrientation: PlayerCameraOrientation, deltaTimeMs: number) {
    if (!entity.isSpawned || !entity.world) return;

    super.tickWithPlayerInput(entity, input, cameraOrientation, deltaTimeMs);

    const { w, a, s, d, sp, sh, ml } = input;
    const { yaw } = cameraOrientation;
    const currentVelocity = entity.linearVelocity;
    const targetVelocities = { x: 0, y: 0, z: 0 };
    const isRunning = sh;

    // Temporary, animations
    if (this.isGrounded && (w || a || s || d)) {
      if (isRunning) {
        const runAnimations = [ 'run_upper', 'run_lower' ];
        entity.stopModelAnimations(Array.from(entity.modelLoopedAnimations).filter(v => !runAnimations.includes(v)));
        entity.startModelLoopedAnimations(runAnimations);
        this._stepAudio?.setPlaybackRate(0.81);
      } else {
        const walkAnimations = [ 'walk_upper', 'walk_lower' ];
        entity.stopModelAnimations(Array.from(entity.modelLoopedAnimations).filter(v => !walkAnimations.includes(v)));
        entity.startModelLoopedAnimations(walkAnimations);
        this._stepAudio?.setPlaybackRate(0.55);
      }

      this._stepAudio?.play(entity.world, !this._stepAudio?.isPlaying);
    } else {
      this._stepAudio?.pause();
      const idleAnimations = [ 'idle_upper', 'idle_lower' ];
      entity.stopModelAnimations(Array.from(entity.modelLoopedAnimations).filter(v => !idleAnimations.includes(v)));
      entity.startModelLoopedAnimations(idleAnimations);
    }

    if (ml) {
      entity.startModelOneshotAnimations([ 'simple_interact' ]);
      input.ml = false;
    }

    // Calculate target horizontal velocities (run/walk)
    if ((isRunning && this.canRun(this)) || (!isRunning && this.canWalk(this))) {
      const velocity = isRunning ? this.runVelocity : this.walkVelocity;

      if (w) {
        targetVelocities.x -= velocity * Math.sin(yaw);
        targetVelocities.z -= velocity * Math.cos(yaw);
      }
  
      if (s) {
        targetVelocities.x += velocity * Math.sin(yaw);
        targetVelocities.z += velocity * Math.cos(yaw);
      }
      
      if (a) {
        targetVelocities.x -= velocity * Math.cos(yaw);
        targetVelocities.z += velocity * Math.sin(yaw);
      }
      
      if (d) {
        targetVelocities.x += velocity * Math.cos(yaw);
        targetVelocities.z -= velocity * Math.sin(yaw);
      }

      // Normalize for diagonals
      const length = Math.sqrt(targetVelocities.x * targetVelocities.x + targetVelocities.z * targetVelocities.z);
      if (length > velocity) {
        const factor = velocity / length;
        targetVelocities.x *= factor;
        targetVelocities.z *= factor;
      }
    }

    // Calculate target vertical velocity (jump)
    if (sp && this.canJump(this)) {
      if (this.isGrounded && currentVelocity.y > -0.001 && currentVelocity.y <= 3) {
        targetVelocities.y = this.jumpVelocity;
      }
    }

    // Apply impulse relative to target velocities, taking platform velocity into account
    const platformVelocity = this._platform ? this._platform.linearVelocity : { x: 0, y: 0, z: 0 };
    const deltaVelocities = {
      x: targetVelocities.x - currentVelocity.x + platformVelocity.x,
      y: targetVelocities.y + platformVelocity.y,
      z: targetVelocities.z - currentVelocity.z + platformVelocity.z,
    };

    const hasExternalVelocity = 
      Math.abs(currentVelocity.x) > this.runVelocity ||
      Math.abs(currentVelocity.y) > this.jumpVelocity ||
      Math.abs(currentVelocity.z) > this.runVelocity;
    
    if (!hasExternalVelocity || this.isOnPlatform) { // allow external velocities to resolve, otherwise our deltas will cancel them out.
      if (Object.values(deltaVelocities).some(v => v !== 0)) {
        const mass = entity.mass;        

        entity.applyImpulse({ // multiply by mass for the impulse to result in applying the correct target velocity
          x: deltaVelocities.x * mass,
          y: deltaVelocities.y * mass,
          z: deltaVelocities.z * mass,
        });
      }
    }

    // Apply rotation
    if (yaw !== undefined) {
      const halfYaw = yaw / 2;
      
      entity.setRotation({
        x: 0,
        y: Math.fround(Math.sin(halfYaw)),
        z: 0,
        w: Math.fround(Math.cos(halfYaw)),
      });
    }
  }
}
Diving Deeper
The PlayerEntityController class is constantly evolving. You can find the latest PlayerEntityController API Reference here.

If there are features that we don't currently support for the PlayerEntityController that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Simple Entity Controller
The SimpleEntityController class provides simple movement controls for entities. It's a great starting point if you're building basic pathfinding of have simple movement needs of your entities. You can piece together it's .move()and .face()methods to create simple pathfinding and behaviors relatively quickly.

Using a SimpleEntityController with an Entity
You can assign a SimpleEntityController to your Entity when it spawns or at any point in its lifecycle. In this example, we'll assign the controller when our entity spawns.

Copy
import {
  Entity,
  SimpleEntityController,
  // ... other imports
} from 'hytopia';

// other code ...

// Create a spider entity instance with our entity controller
const spider = new Entity({
  controller: new SimpleEntityController(),
  modelUri: 'models/npcs/spider.gltf',
  modelScale: 2.5,
  modelLoopedAnimations: [ 'idle' ],
});
â€‹
// Spawn the spider in the world.
spider.spawn(world, { x: 0, y: 10, z: -15 });

// have the spider face towards and move towards the target
// position, taking physics into account.
const target = { x: 0, y: 0, z: 0 };
const spiderEntityController = spider.controller as SimpleEntityController;
spiderEntityController.move(target, 3); // move towards target at a speed of 3 (approx. blocks per second)
spiderEntityController.face(target, 1); // face towards the target a speed of 1
SimpleEntityController Implementation
For the sake of demonstration and reference for creating your own controllers or modifying the existing SimpleEntityController, you can find the current internal implementation below:

Copy
/**
 * A callback function called when the entity associated with the
 * SimpleEntityController updates its rotation as it is
 * attempting to face a target coordinate.
 * @param currentRotation - The current rotation of the entity.
 * @param targetRotation - The target rotation of the entity.
 * @public
 */
export type FaceCallback = (currentRotation: QuaternionLike, targetRotation: QuaternionLike) => void;

/**
 * A callback function called when the entity associated with the
 * SimpleEntityController finishes rotating and is now facing 
 * a target coordinate.
 * @param endRotation - The rotation of the entity after it has finished rotating.
 * @public
 */
export type FaceCompleteCallback = (endRotation: QuaternionLike) => void;

/**
 * Options for the {@link SimpleEntityController.face} method.
 * @public
 */
export type FaceOptions = {
  faceCallback?: FaceCallback;
  faceCompleteCallback?: FaceCompleteCallback;
}

/**
 * A callback function called when the entity associated with the
 * SimpleEntityController updates its position as it is
 * attempting to move to a target coordinate.
 * @param currentPosition - The current position of the entity.
 * @param targetPosition - The target position of the entity.
 * @public
 */
export type MoveCallback = (currentPosition: Vector3Like, targetPosition: Vector3Like) => void;

/**
 * A callback function called when the entity associated with the
 * SimpleEntityController reaches the target coordinate. An entity
 * must reach the x,y,z coordinate for the callback to be called.
 * @param endPosition - The position of the entity after it has finished moving.
 * @public
 */
export type MoveCompleteCallback = (endPosition: Vector3Like) => void;

/**
 * Options for the {@link SimpleEntityController.move} method.
 * @public
 */
export type MoveOptions = {
  /** Callback called each tick movement of the entity controller's entity. */
  moveCallback?: MoveCallback;

  /** Callback called when the entity controller's entity has finished moving. */
  moveCompleteCallback?: MoveCompleteCallback;

  /** Axes to ignore when moving the entity controller's entity. Also ignored for determining completion. */
  moveIgnoreAxes?: { x?: boolean, y?: boolean, z?: boolean };
}

/**
 * A simple entity controller with basic movement functions.
 * 
 * @remarks
 * This class implements simple movement methods that serve
 * as a way to add realistic movement and rotational facing
 * functionality to an entity. This is also a great base to
 * extend for your own more complex entity controller
 * that implements things like pathfinding. Compatible with
 * entities that have kinematic or dynamic rigid body types.
 * 
 * @example 
 * ```typescript
 * // Create a custom entity controller for myEntity, prior to spawning it.
 * myEntity.setController(new SimpleEntityController());
 * 
 * // Spawn the entity in the world.
 * myEntity.spawn(world, { x: 53, y: 10, z: 23 });
 * 
 * // Move the entity at a speed of 4 blocks
 * // per second to the coordinate (10, 1, 10).
 * // console.log when we reach the target.
 * myEntity.controller.move({ x: 10, y: 1, z: 10 }, 4, {
 *   moveCompleteCallback: endPosition => {
 *     console.log('Finished moving to', endPosition);
 *   },
 * });
 * ```
 * 
 * @public
 */
export default class SimpleEntityController extends BaseEntityController {
  /** @internal */
  private _faceSpeed: number = 0;

  /** @internal */
  private _faceTarget: Vector3Like | undefined;

  /** @internal */
  private _moveSpeed: number = 0;

  /** @internal */
  private _moveTarget: Vector3Like | undefined;

  /** @internal */
  private _moveIgnoreAxes: { x?: boolean, y?: boolean, z?: boolean } = {};

  /** @internal */
  private _onFace: FaceCallback | undefined;

  /** @internal */
  private _onFaceComplete: FaceCompleteCallback | undefined;

  /** @internal */
  private _onMove: MoveCallback | undefined;

  /** @internal */
  private _onMoveComplete: MoveCompleteCallback | undefined;

  /**
   * Rotates the entity at a given speed to face a target coordinate.
   * 
   * @remarks
   * If this method is called while the entity is already attempting
   * to face another target, the previous target will be ignored and
   * the entity will start attempting to face the new target.
   * 
   * @param target - The target coordinate to face.
   * @param speed - The speed at which to rotate to the target coordinate.
   * @param options - Additional options for the face operation, such as callbacks.
   */
  public face(target: Vector3Like, speed: number, options?: FaceOptions): void {
    this._faceTarget = target;
    this._faceSpeed = speed;
    this._onFace = options?.faceCallback;
    this._onFaceComplete = options?.faceCompleteCallback;
  }

  /**
   * Moves the entity at a given speed in a straight line to a target coordinate.
   * 
   * @remarks
   * If this method is called while the entity is already attempting
   * to move to another target, the previous target will be ignored and
   * the entity will start attempting to move to the new target.
   * 
   * @param target - The target coordinate to move to.
   * @param speed - The speed at which to move to the target coordinate.
   * @param options - Additional options for the move operation, such as callbacks.
   */
  public move(target: Vector3Like, speed: number, options?: MoveOptions): void {
    this._moveTarget = target;
    this._moveSpeed = speed;
    this._moveIgnoreAxes = options?.moveIgnoreAxes ?? {};
    this._onMove = options?.moveCallback;
    this._onMoveComplete = options?.moveCompleteCallback;
  }

  /** @internal */
  public tick(entity: Entity, deltaTimeMs: number): void {
    super.tick(entity, deltaTimeMs);

    if (!this._moveTarget && !this._faceTarget) {
      return;
    }

    const deltaTimeSeconds = deltaTimeMs / 1000;
    const currentPos = entity.position;

    if (this._moveTarget) {
      const direction = {
        x: this._moveIgnoreAxes.x ? 0 : this._moveTarget.x - currentPos.x,
        y: this._moveIgnoreAxes.y ? 0 : this._moveTarget.y - currentPos.y,
        z: this._moveIgnoreAxes.z ? 0 : this._moveTarget.z - currentPos.z,
      };

      const distanceSquared = direction.x * direction.x + 
                              direction.y * direction.y + 
                              direction.z * direction.z;

      if (distanceSquared > 0.1) {
        const distance = Math.sqrt(distanceSquared);
        const maxMove = this._moveSpeed * deltaTimeSeconds;
        const moveDistance = Math.min(distance, maxMove);
        const moveScale = moveDistance / distance;
        const position = {
          x: currentPos.x + direction.x * moveScale,
          y: currentPos.y + direction.y * moveScale,
          z: currentPos.z + direction.z * moveScale,
        };

        entity.setPosition(position);

        if (this._onMove) {
          this._onMove(position, this._moveTarget);
        }
      } else {
        this._moveTarget = undefined;

        if (this._onMoveComplete) {
          this._onMoveComplete(currentPos);
          this._onMoveComplete = undefined;
        }
      }
    }

    if (this._faceTarget) {
      const direction = {
        x: this._faceTarget.x - currentPos.x,
        z: this._faceTarget.z - currentPos.z,
      };

      // Calculate yaw angle to face target (-z facing since -z is forward)
      const targetYaw = Math.atan2(-direction.x, -direction.z);
      
      const currentRotation = entity.rotation;
      const currentYaw = Math.atan2(
        2 * (currentRotation.w * currentRotation.y), 
        1 - 2 * (currentRotation.y * currentRotation.y),
      );

      // Calculate shortest angle difference
      let angleDiff = targetYaw - currentYaw;
      
      // Normalize angle difference to [-Ï€, Ï€] range for shortest path
      while (angleDiff > Math.PI) {
        angleDiff -= 2 * Math.PI;
      }
      
      while (angleDiff < -Math.PI) {
        angleDiff += 2 * Math.PI;
      }

      if (Math.abs(angleDiff) > 0.01) {
        // Smoothly rotate towards target using shortest path
        const maxRotation = this._faceSpeed * deltaTimeSeconds;
        const rotationAmount = Math.abs(angleDiff) < maxRotation ? angleDiff : Math.sign(angleDiff) * maxRotation;
        const newYaw = currentYaw + rotationAmount;
        const halfYaw = newYaw / 2;
        const rotation = {
          x: 0,
          y: Math.fround(Math.sin(halfYaw)),
          z: 0,
          w: Math.fround(Math.cos(halfYaw)),
        };

        entity.setRotation(rotation);

        if (this._onFace) {
          this._onFace(currentRotation, rotation);
        }
      } else {
        this._faceTarget = undefined;

        if (this._onFaceComplete) {
          this._onFaceComplete(entity.rotation);
          this._onFaceComplete = undefined;
        }
      }
    }
  }
}
Diving Deeper
The SimpleEntityController class is constantly evolving. You can find the latest SimpleEntityController API Reference here.

If there are features that we don't currently support for the SimpleEntityController that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Entity Manager
In more complex games, it's common to have many different entities spawned at the same time. This can become cumbersome to track or manage, especially if you need to do things like perform operations on specific entities.

Thankfully, we have the EntityManager that exposes ways to quickly retrieve and iterate all spawned Entities in a world.

Accessing An EntityManager
The EntityManager is used as a singleton and automatically created for a given world instance.

You can access the entity manager for a world like this:

Copy
world.entityManager
Using An EntityManager
The EntityManager exposes a number of ways to get different types of Entities for a world. Here's some examples of how you can use it.

Copy
// Returns an array of all spawned entities
// for the world
world.entityManager.getAllEntities();

// Returns an array of all spawned player
// entities for the world
world.entityManager.getAllPlayerEntities();

// Get an array of player entities currently assigned to
// the provided player. Players can have more than 1
// player entity, such as games where a player's input may
// control multiple entities at once.
world.entityManager.getPlayerEntitiesByPlayer(player)

// Get an array of entities by exact tag match
world.entityManager.getEntitiesByTag('zombie');

// Get an array of entities by tag substring match
// 'o' for example would match tags like zombie, ostritch, igloo  
world.entityManager.getEntitiesByTagSubstring('o');
Diving Deeper
The EntityManager class is constantly evolving. You can find the latest EntityManager API Reference here.

If there are features that we don't currently support for EntityManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Model Entities
Model entities are an entity that is visually representing by a .gltf or .glb model. Model entities are the most common type of entity you'll use. For example, players, enemies in your game, fixed and moving elements like lamp-posts or birds, and more, will typically be created using an Entity.

Common Uses & Examples
Let's dive into some common patterns when using model entities.

Bullet Entity
Some games may want a bullet that moves through the physical world and registers a hit when it intersects with another entity. You could alternatively just use a Raycasts for this, but in this example we'll use an entity.

Copy
const bullet = new Entity({
  name: 'Bullet',
  modelUri: 'models/bullet.gltf',
  modelScale: 0.3,
  rigidBodyOptions: {
    type: RigidBodyType.KINEMATIC_VELOCITY, // Kinematic means entity's rigid body will not be affected by physics. KINEMATIC_VELOCITY means the entity is moved by setting velocity.
    linearVelocity: { // Setting the linear velocity on a Kinematic type means it will move at a constant speed, unaffect by gravity or other forces
      x: direction.x * BULLET_SPEED,
      y: direction.y * BULLET_SPEED,
      z: direction.z * BULLET_SPEED,
    },
  },
});

bullet.on(EntityEvent.ENTITY_COLLISION, ({ otherEntity, started }) => {
  if (!started) { return } // we only care about the initial hit, not when it stops
  
  // Perform your bullet logic here, the otherEntity is the entity the bullet hit.
  // You can do things like despawn the entity that was hit, use your own damage
  // logic, and more. 
});
Extra Large Entity
With model entities, you can control their physical scaling in the world. This allows you to scale up or down the model of the entity relative to its initial size. We'll use model scale to create a massive spider.

Copy
const spider = new Entity({
  modelUri: 'models/npcs/spider.gltf',
  modelScale: 10, // 10x the default scale
  modelLoopedAnimations: [ 'idle' ],
});

// Spawn the spider in the world.
spider.spawn(world, { x: 0, y: 3, z: -15 });
Now, we'll see a massive spider!


Automatic Model Optimizations
Typically, most model editing software will export your .gltfand .glbmodels with many internal meshes and named nodes. The more unique meshes & named nodes that make up your model, the more strain it puts on a device's GPU when your game is played. If you have a variety of loaded entity models at the same time, or your models have many complex meshes, this can cause a significant degradation of frame rate and overall game performance for players.

Because of this, the HYTOPIA SDK when you run your game server, and when your game is uploaded to the HYTOPIA platform, will automatically run a variety of optimization passes on each of your models and output them into a hidden .optimizedfolder in your game's assetsfolder. 

Each model is ran internally through our gltf-transform based optimizer, performing operations like merging redundant meshes, named nodes, and other optimizations in various combinations, resulting in multiple .gltfmodels for the same input model, outputted into the automated .optimizeddirectory.

The HYTOPIA client based on how you use your models will try to load the most optimal version of that model at runtime. This results in the best model for performance & your usage being used automatically, dramatically improving device frame rate and performance.

Overall, you don't need to manage or do anything with this system. It is automated and 100% internally managed. 

If for some reason you are experiencing unusual behavior that you think is coming from optimized models, you can disable model optimization globally by invoking the following method of the ModelRegistry class at the beginning of your index.ts game script.

Copy
// If you're disabling the optimizer, this boolean must be set before `startServer()`.
ModelRegistry.instance.optimize = false;

startServer(world => {
  // game code...
});
Movement & Pathfinding
Controlling movement or making entities move by pathfinding is critical to many types of games. The HYTOPIA SDK exposes a number of building block primitives you can use to create your own movement logic and pathfinding systems.

Important Building Blocks & Primitives
Below are the most frequently used building blocks and primitives when creating movement and pathfinding logic for entities.

SimpleCharacterController
The first building block that's best suited for relatively simple pathfinding is the #simpleentitycontroller. This entity controller implements basic movement and facing functions to create realistic movement behaviors with defined speeds.

RigidBody
All entities inherit from the RigidBody class. Rigid bodies have a number of physics properties and controls that are necessary for creating custom movement and pathfinding logic. This means, any property or method that the RigidBody class has, an Entity does as well.

We recommend you look through the RigidBody API Reference here to see a full list of available properties and methods.

ChunkLattice
If you're creating more complex pathfinding, you'll likely want to iterate the nearby terrain state of the world to determine the path an entity should take for it's movement. You can use a world's chunk lattice for this. The chunk lattice is useful for retrieving the chunks near an entity, or seeing if specific coordinates have a block set or not, or what kind of block is set. Learn more about the ChunkLattice.

Basic Waypoint Movement Example
We can create some basic movement behavior by providing a set of waypoints our entity will move through. The SimpleCharacterController used will take the most immediate path to the next target waypoint, colliding and potentially being stopped by any terrain or entities in the way. This is simple, dumb movement in this case.

Copy
// ... other code

let targetWaypointIndex = 0;

const WAYPOINT_COORDINATES = [
  { x: -5, y: 1, z: -7 },
  { x: 15, y: 1, z: 10 },
  { x: 17, y: 1, z: -12 },
];

const cow = new Entity({
  controller: new SimpleEntityController(),
  modelUri: 'models/npcs/cow.gltf',
  modelScale: 0.7,
  modelLoopedAnimations: [ 'walk' ],
  modelAnimationsPlaybackRate: 1.6, // roughly match the animation speed to the move speed we'll use
  rigidBodyOptions: {
    enabledRotations: { x: false, y: true, z: false }, // prevent flipping over when moving
  },
});

// We want to face towards the target each tick, since our relative position
// to the target may change as we move from a previous waypoint to the next.
cow.on(EntityEvent.TICK, () => {
  if (targetWaypointIndex >= WAYPOINT_COORDINATES.length) {
    return; // reached final waypoint, no need to rotate
  }

  // continually face towards target as we move
  const controller = cow.controller as SimpleEntityController;
  const targetWaypoint = WAYPOINT_COORDINATES[targetWaypointIndex];
  controller.face(targetWaypoint, 5);
});

cow.spawn(world, { x: 0, y: 3, z: 0 });

// Pathfind to the next waypoint as we reach each waypoint
const pathfind = () => {
  if (targetWaypointIndex >= WAYPOINT_COORDINATES.length) {
    cow.stopModelAnimations(['walk']);
    cow.startModelLoopedAnimations(['idle']);

    return; // reached final waypoint, no need to pathfind
  }
      
  const controller = cow.controller as SimpleEntityController;
  const targetWaypoint = WAYPOINT_COORDINATES[targetWaypointIndex];
    
  // Makes the controlled entity, the cow, start moving towards the waypoint
  // It will automatically handle it's own internal tick for movement.
  controller.move(targetWaypoint, 3, {
    moveCompleteCallback: () => {
      // pathfind to next waypoint
      targetWaypointIndex++; 
      pathfind();
    },
    moveIgnoreAxes: { x: false, y: true, z: false }, // ignore our y position when considering if movement is complete 
  });
};

pathfind();
Here's what our movement for our cow looks like!


The result of our movement example.
Complex A* Pathfinding
The HYTOPIA SDK provides an out of the box, generalized and configurable Pathfinding Entity Controller that can be used to implement pathfinding that takes complex obstacles and terrain into consideration when moving to a target entity or position.

We recommend you take a look at the pathfinding entity example in the SDK to see an up to date example of how you can implement the PathfindingEntityController for your own entities.

Player Controlled Entities
Player controlled entities, represented by the PlayerEntity class, are entities that are controlled by a player's inputs. Player controlled entities can be either a Model Entitiesor a Block Entities. Yes, that means if you really want, you could even have players control a movable block in your game!

PlayerEntity Class & Entity Controllers
The behavior of the PlayerEntity class based on player inputs is dependent on the logic in it's entity controller (playerEntityInstance.controller). 

In our Entity Controllers section, we covered the lifecycle of an entity controller. Entity controllers have a special lifecycle method called tickWithPlayerInput(). A PlayerEntity invokes this method of it's controller every tick, passing the current inputs of the player to it.

Through this, the PlayerEntity class, which represents a player controlled entity, is controlled through the logic of it's entity controller based on the input of the player each tick.

To learn more about player inputs and controls, check out Input & Controls

Creating A PlayerEntity
Here's an example from our boilerplate, showcasing how we create a new player entity controlled by a player when they join our game.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  const playerEntity = new PlayerEntity({
    // PlayerEntity accepts an additional property 
    // in its options, player, which is the player
    // who's inputs will control the actions of this
    // entity. The default PlayerEntityController()
    // is assigned to this entity, since we did not
    // override it by specifying the `controller: new MyCustomController()`
    // property option.
    player,
    name: 'Player',
    modelUri: 'models/players/player.gltf',
    modelLoopedAnimations: [ 'idle' ],
    modelScale: 0.5,
  });
  
  playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
});
You can learn more about the PlayerEntity class options here.

Events
The HYTOPIA SDK is heavily designed around an event-driven architecture. This means that games, plugins, and even internal systems all make use of event emission and event listeners for when different things happen.

Events allow you to create in a highly flexible way by creating listeners that invoke a callback whenever something you subscribe to happens. For example..

Did an entity collide with another specific entitiy? 

Did an entity despawn?

Did a chunk get removed?

Did a light despawn?

Did some audio begin playing?

All of these examples cause events to be emitted when they happen. You can with a single line of code create logic that executes whenever any event you subscribe to happens. Many of these events also include contextually relevant data for the event as well!

Understanding Events & Event Emission
In the HYTOPIA SDK, nearly all instances of classes that you use are also an event emitter (aka an EventRouter within the SDK). This means that all instances of these classes can be specifically listened to for events that happen using common patterns like .on() . 

When these instances emit events, they emit 2 copies of the event. 

One copy of an emitted event emits to any listeners specifically on the instance itself. For example if you have a listener assigned with myZombieEntity.on(EntityEvent.TICK, () â‡’ { ... }) , anytime that specific entity ticks, the TICK event listener you assigned will be invoked.

The other copy of an emitted event emits through World instance that the emitting class instance belongs to. Per our previous example, lets assume myZombieEntity belongs to our world instance, so when it ticks, it emits a tick event through itself, and  also through the World instance it belongs to. This allows you to do things like listen to all events of any type that emit by any instance of any class that is within a world. For example, we could add an event listener that is invoked every tick for every entity belonging to our world instance with world.on(EntityEvent.TICK, () â‡’ { ... }

This granular implementation of event routing allows you to optimally fine tune your game logic and behaviors based on whatever you need. This also makes it highly flexible to create your own Plugins for others to use as well!

Here's an example to better demonstrate this:

Copy
import {
  startServer,
  Entity
  EntityEvent,
} from 'hytopia'

startServer(world => {
  world.loadMap(worldMap);

  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    const playerEntity = new PlayerEntity({
      player,
      name: 'Player',
      modelUri: 'models/players/player.gltf',
      modelLoopedAnimations: [ 'idle' ],
      modelScale: 0.5,
    });
    
    // Callback is invoked only once when this specific playerEntity instance spawns.
    playerEntity.once(EntityEvent.SPAWN, payload => {
      console.log(`A player entity spawned for ${player.username}!`);
    });

    playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
  });
 
  // Callback is invoked anytime ANY entity spawns in the world.
  world.on(EntityEvent.SPAWN, payload => {
    const entity = payload.entity;    
    console.log(`A new entity spawned with id ${entity.id} and name ${entity.name}!`);
  });
});
Event & Event  Payload Documentation
The HYTOPIA SDK API Reference is the #1 place to find documentation and details on available events. 

All classes that can emit events, will have an Events section within their documentation. For example, Entity events: https://github.com/hytopiagg/sdk/blob/main/docs/server.entity.md#events

This is true for other commonly used classes like Audio, BlockType, Light, and many others.

In this Events section within the documentation, you'll find a link to the exact events and payloads available for a given class. Additionally all events are available as enums through the SDK, rather than directly using a string for the event name. For example, all Entity events can be found and used through the EntityEvent enum.

Additionally, most modern IDEs with Typescript support will automatically be able to infer the expected payload for all event types and provide hints.

Supported Event Methods
All classes that can emit events will inherit from the EventRouter class. This means that all methods available through the EventRouterclass, will also be available to any class that inherits from it. This includes methods like .on(), .off(), .once() and more. 

All Known SDK Events
If for any reason you need to reference all known SDK events, you can find them here: https://github.com/hytopiagg/sdk/blob/main/docs/server.eventpayloads.md 

Input & Controls
Making unique game mechanics based on different player inputs can be critical for great games. Because HYTOPIA is architected as a purely server-authoritative game engine, that means all player inputs are streamed to your game, allowing you to directly control the outcome of player inputs each tick! 

This is really powerful and allows you to create unique gameplay experiences without replicating input logic between client and server. 

Available Inputs
Below is a list of inputs that the HYTOPIA  game client will send to your game each tick for each player. You can build custom game logic around any state of these inputs. 

These inputs for the relevant player are passed to the onTickWithPlayerInput() method of an Entity Controller every tick. You can also access the current input state of any player though player.inputand player.camera.orientation. 

Input
Type
Input State Key(s)
Mobile Support?
W

Boolean (true when pressed, false when not)

w


A

Boolean (true when pressed, false when not)

a


S

Boolean (true when pressed, false when not)

s


D

Boolean (true when pressed, false when not)

d


Mouse Left Click

Boolean (true when pressed, false when not)

ml


Mouse Right Click

Boolean (true when pressed, false when not)

mr


Camera Orientation - Pitch 

Number (in radans)

pitch


Camera Orientation - Yaw

Number (in radians)

yaw


Spacebar

Boolean (true when pressed, false when not)

sp


Shift

Boolean (true when pressed, false when not)

sh


Q

Boolean (true when pressed, false when not)

q


E

Boolean (true when pressed, false when not)

e


R

Boolean (true when pressed, false when not)

r


F

Boolean (true when pressed, false when not)

f


Z

Boolean (true when pressed, false when not)

z


X

Boolean (true when pressed, false when not)

x


C

Boolean (true when pressed, false when not)

c


V

Boolean (true when pressed, false when not)

v


Numbers 1-9

Boolean (true when pressed, false when not)

1, 2, 3, 4, 5, 6, 7, 8, 9


You can see the most up to date list of supported inputs in the server protocol repository's InputSchema, here.

Input states are currently stored on the Player class' input (player.input)  as abbreviated keys as listed in the table above.

Using Player Inputs
For a great example of how you can use player inputs to specify how a PlayerEntity is controlled, you can check out the Player Entity Controller which shows how it implements the onTickWithPlayerInput()method.

Mobile Support
The HYTOPIA game client implements a set of touch controls on mobile devices like phones and tablets. Because these devices do not have a keyboard and mouse, we are only able to natively support a subset of the full inputs available. See the table in Available Inputs for details.

If you need additional touch inptus for mobile, you can create your own custom user interfaces specifically for mobile devices that overlay additional touch controls. See User Interfaceto learn more.

Cancelling Player Inputs
There may be situations where you need to cancel a current input of a player, even if they haven't stopped pressing it. We can easily do that by setting the input key to false on their player input state as follows.

Copy
// other code ...

player.input['sp'] = false; // cancel out the space bar
Another example, let's say you want to only process shooting 1 bullet every time a player clicks, but we don't want to shoot a bullet every tick of the server while the player is holding the mouse down. We can easily accomplish this with the following input state logic.

Copy
// other code, likely in the onTickWithPlayerInput() method, or somewhere else ...

if (input.ml) { // the left mouse button is clicked
  // .. fire a bullet
  
  // cancel the input, the player will
  // need to depress and repress the mouse
  // button to fire another bullet, which is
  // the behavior we want.
  input.ml = false;
}
Lighting
Lighting is a critical piece for making a game look and feel a certain way to players. The HYTOPIA SDK gives developers full control of the most common types of lighting a game might need.

Lighting is controlled in a few different ways depending on the lighting type. For example, ambient and directional light is controlled through a World instance, while point lights and spot lights are controlled through an instance of the Light class.


Ambient light and sun light used together to create a day/night cycle.
Types Of Lights
There's 5 types of lighting that HYTOPIA supports. All lighting besides emissive lights are dynamic and will cast physically accurate shadows in real time. All lights automatically interpolated value changes for smooth visual changes to lighting effects. We'll cover the 5 lighting types below.

Ambient Light - Ambient light is the base lighting of the entire world. This determines the minimum brightness and light color of your world.

Emissive Lights - Emissive lights can emit light from static/fixed game elements like blocks. This lighting is the only lighting that will not cast shadows. Emissive lights are not yet supported!

Point Lights - Point lights are lights that emit from a fixed point in space. They can move dynamically through the world, follow entities, have their color or intensity controlled in real time and more. Point lights are real time lights that are graphically expensive and should be used sparingly.

Spot Lights - Spot lights are lights taht emit from a fixed point in space in a cone-like shape. They can move dynamically through the world, track a position or an entity and have their angle, color, intensity and penumbra controlled. Spot lights are real time lights that are graphically expensive and should be used sparingly.

Sun Light (aka Directional Light) - Sun light, also known as the directional light, is a single light source emitting from a set position. It casts a light across the entire world relative to its position with a intensity and color you can control. Its position when updated is automatically interpolated, as well as its color, so it can be used to control lighting effects like day/night cycles, and more.

Next Steps
Ambient Light

Learn more about ambient lighting and how to use it.

Light Manager

Learn more about the light manager that tracks and allows lookup of point lights and spot lights in a world.

Point Lights

Learn more about point lights that emit light from a point in the world.

Spot Lights

Learn more about spot lights that emit a cone shaped spot light from a point in the world.

Sun Light

Learn more about sun light that emits a directional light from the sky across the entire world.

Ambient Light
Ambient light is the base light that fills the entirety of a world, regardless of caves or other occluding elements. If you're using ambient light with the Sun Light (Directional light), you can think of ambient light as the minimum lighting in your world.

Color & Intensity
The ambient light allows you to control its color using an RGB value, and its intensity as a number.

The ambient light color and intensity can be changed anytime during gameplay to update the world's overall lighting.

Here's how we can change a world's ambient light color.

Copy
// ... other code
world.setAmbientLightColor({ r: 255, g: 0, b: 0 }); // very red ambient lighting
Here's how we can change a world's ambient light intensity. Ambient lighting intensity can be a value from 0 to 1+, with 1 being the default brightness, and anything above that being additional brightness.

Copy
// ... other code
world.setAmbientLightIntensity(20); // Very over-exposed, ultra bright lighting
You can use both the light color and intensity in combination to get your ambient lighting for a world.

Diving Deeper
The latest ambient lighting API Reference can be found as part of the World API Reference here.

If there are features that we don't currently support for ambient lighting that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Light Manager
Managing dynamic lighting like point lights and spot lights in a game can be an added burden without any out of the box helpers. 

Thankfully, the HYTOPIA SDK ships with a Light Manager, allowing you to retrieve Light instances of point lights and spot lights in a world.

Accessing A LightManager
The LightManager is used as a singleton and automatically created for a given world instance.

You can access the light manager for a world like this:

Copy
world.lightManager
Using A LightManager
The LightManager exposes a number of ways to get Light instances for a world. Light instances will either be a point light, or spot light. Here's an exampel of how to use it.

Copy
// Returns an array of all loaded light instances
// for the world
world.lightManager.getAllLights();

// Returns an array of all loaded light instances
// attached to the provided entity
world.lightManager.getAllEntityAttachedLights(someEntity);
Diving Deeper
The LightManager class is constantly evolving. You can find the latest LightManager API Reference here.

If there are features that we don't currently support for LightManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Point Lights
Points lights emit light of a specific color and intensity from a positional point in the world. 

Point lights are real time lighting, meaning they will cast shadows and recalculate light each frame based on the objects in proximity of the light. This also means that point lights come at a much performance cost than ambient and directional lighting. Use point lights sparingly.


A basic point light attached to our player's entity, emitting light around the player as they move.
Creating A Point Light
Point lights are created as a Light instance. The pattern of point light usage is similar to entities. You must create an instance of a Light first, then spawn the light in the world. Here's how we can do that.

Copy
const light = new Light({
  color: { r: 255, g: 0, b: 0 }, // the lights color, defaults to 255,255,255
  intensity: 5, // the lights intensity, defaults to 1
  position: { x: 10, y: 20, z: -10 } // where the point light emits in the world 
});

light.spawn(world);
Point Light Entity Attachment
You can attach a point light to follow an entity as the entity moves throughout the world like this.

Copy
const light = new Light({
  attachedToEntity: playerEntity, // the entity to follow
  color: { r: 255, g: 0, b: 0 },
  intensity: 5,
  offset: { x: 0, y: 1, z: 0 }, // an offset of the pointlight relative to the attached entity
});

light.spawn(world);
Diving Deeper
The Light class, which is used to create point lights, supports a wide variety of features and is constantly evolving. If you'd like to learn more, we recommend you dig into the Light API Reference here.

If there are features that we don't currently support for point lights that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Spot Lights
Spot lights emit in a cone shape from a position towards a target position or tracked entity. Spot lights can have their color, intensity, angle and penumbra controlled. 

Spot lights are real time lighting and will recalculate light each frame based on object in the proximity of the light. This means spot lights come at a higher performance cost than ambient or directional lighting. Use spot lights sparingly.


Spot lights positioned to emit light from holes in a cave for a more realistic lighting effects on the ground.
Creating A Spot Light
Spot lights are created as a Light instance. The pattern of spot light usage is similar to entities. You must create an instance of a Light first, then spawn the light in the world. Here's how we can do that.

Copy
const light = new Light({
  type: LightType.SPOTLIGHT,
  angle: Math.PI / 8, // Spot light angle in radians
  color: { r: 255, g: 200, b: 200 }, // A pinkish color 
  intensity: 40,
  penumbra: 0.5, // Spot light penumbra
  position: { x: 0, y: 15, z: 0 }, // Position the spot light shines from
  trackedPosition: { x: 0, y: 0, z: 0 }, // Position the spot light shines towards
});

light.spawn(world);
Spot Light Entity Attachment & Tracking
One of the powerful features of spot lights is it's ability to be attached to an entity, or a fixed position, while the light shines towards a tracked position or tracked entity. 

We can attach a spot light to an entity, and make it track another entity so that as the entities move around in the game the spot light continues to track the target relative to the attached entity's position.

Copy
const light = new Light({
  type: LightType.SPOTLIGHT,
  attachedToEntity: someEntity,
  angle: Math.PI / 8, // Spot light angle in radians
  intensity: 40,
  penumbra: 0.5, // Spot light penumbra
  trackedEntity: someOtherEntity,
});

light.spawn(world);
Alternatively, we can just as easily create our spot light at a fixed position, while tracking an entity.

Copy
const light = new Light({
  type: LightType.SPOTLIGHT,
  position: { x: -7, y: 10, z: -11 }, 
  angle: Math.PI / 8, // Spot light angle in radians
  intensity: 40,
  penumbra: 0.5, // Spot light penumbra
  trackedEntity: someOtherEntity,
});

light.spawn(world);
Positional & Tracking Updates
Spot light position, attachments and tracking properties can be updated at any point after being spawned. This allows you to create smooth movement and light tracking effects while using spotlights. The HYTOPIA client will automatically handle interpolation of these updates for smooth changes.

Diving Deeper
The Light class, which is used to create spot lights, supports a wide variety of features and is constantly evolving. If you'd like to learn move, we recommend you dig into the Light API Reference here.

If there are features that we don't currently support for spot lights that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Sun Light (Directional)
Sun light (Also known as directional light) is a single light source that shines from a relative position across the entirety of a world. 

Controlling Sun Light
The sun light, which is called directional light, is controlled through a World instance. We're able to control its color, intensity and position. 

The sun light's properties can be changed at anytime during gameplay.

Here's how we can change a world's sun light color.

Copy
world.setDirectionalLightColor({ r: 255, g: 0, b: 0 }); // A red sun light
Here's how we can change a world's sun light intensity. Intensity can be a value from 0 to 1+, with 1 being the default brightness, and anything above that being additional brightness.

Copy
world.setDirectionalLightIntensity(10); // Very bright lighting
And finally, here's how can update the sun light's position that the light of it directionally emits from across a world.

Copy
world.setDirectionalLightPosition({ x: 500, y: 100, z: 200 });
Basic Day & Night Cycle Example
Here's how we can use ambient & sun light (directional light) to create a day and night cycle for a world.

Copy
// Create a day/night cycle (60 second period)
let time = 0;
const updateRate = world.simulation.timestepS * 8; // update lighting every 8 ticks
const cycleLengthS = 60; // 60 seconds
const CYCLE_STEP = updateRate / cycleLengthS; // 60 fps * 60 seconds
const SUN_ORBIT_RADIUS = 100;
    
setInterval(() => {
  time = (time + CYCLE_STEP) % 1;
  const angle = time * Math.PI * 2;
    
  // Sun position
  const sunY = Math.sin(angle) * SUN_ORBIT_RADIUS;
  const sunZ = Math.cos(angle) * SUN_ORBIT_RADIUS;
    
  // Smooth transition factor (0 to 1)
  const dayProgress = (Math.sin(angle) + 1) / 2; // Normalized to 0-1 range for smooth transitions

  // Interpolate light intensities
  const directionalIntensity = 0.1 + (dayProgress * 0.7); // Smoothly varies between 0.1 and 0.8
  const ambientIntensity = 0.2 + (dayProgress * 0.8); // Smoothly varies between 0.2 and 1

  // Interpolate colors
  const directionalColor = {
    r: 64 + (dayProgress * 191), // 64 to 255
    g: 64 + (dayProgress * 191), // 64 to 255
    b: 128 + (dayProgress * 127), // 128 to 255
  };

  const ambientColor = {
    r: 40 + (dayProgress * 215), // 40 to 255
    g: 40 + (dayProgress * 215), // 40 to 255
    b: 80 + (dayProgress * 175), // 80 to 255
  };

  // Update lighting
  world.setDirectionalLightPosition({ x: 0, y: sunY, z: sunZ });
  world.setDirectionalLightIntensity(directionalIntensity);
  world.setDirectionalLightColor(directionalColor);
  world.setAmbientLightIntensity(ambientIntensity);
  world.setAmbientLightColor(ambientColor);
}, updateRate * 1000);
Here's what our day/night cycle looks like!


Resulting example of our day & night cycle.
Diving Deeper
The latest sun light API Reference can be found as part of the World API Reference here as directional lighting.

If there are features that we don't currently support for sun light that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Players
Players are the starting point of a game! A game in HYTOPIA isn't a game without at least one player.  

When a player joins your game, an instance of the Player class is uniquely created internally, identifying each player and exposing different features and controls over their experience.

Players have a number of methods and properties they expose, allowing you to create and control a variety of aspects of the player's overall experience. Let's dive in!

Player Lifecycle
When players attempt to join your server, assuming your game is live on HYTOPIA and is not a local development server, they'll automatically go through the following lifecycle.

Join Attempt - The player attempts to connect to your game server by clicking "Play" on the HYTOPIA game list, or visiting a direct link to your game. HYTOPIA's internal services will automatically assign them to a HYTOPIA managed server instance of your game relative to their geographical region and meaningful number of other players in a selected instance to maximize their gameplay experience. If a player is joining a game from clicking a Join link in their friends list where a friend is currently playing, they will join the server instance their friend is in.

Player Validation - HYTOPIA's internal services will validate the join request by the player to your game server. If the internal validation succeeds, they will join the server, if not, they will be unable to join.

Player Joins -  If the validation attempt succeeds, your game instance will automatically handle creating a new player instance in your game server and the PlayerEvent.JOINED_WORLDwill be emitted by the world they joined. The payload of the event will include their player object, allowing you to use your own game logic from there.

Overall, you don't need to worry about any aspects of the player join lifecycle, or player matchmaking and server scaling. The HYTOPIA services automatically manage and handle all aspects of this internally for you without you ever needing to think about it.

Player Properties
A player instance exposes a number of useful properties. Here's a quick overview of some of the most useful.

player.id- A globally unique identifier of the player. This id is they player's public HYTOPIA account id. It will be consistent for any game they join.

player.username- A globally unique username of the player. This username is the player's public HYTOPIA username. It will be consistent for any game they join.

player.camera - An instance of the PlayerCamera class, automatically assigned to each player upon them joining your game. You can control aspects of the player's in game camera through this. Learn more here: Camera.

player.input- The current input state of the player for each given tick. You can learn more here: Input & Controls

player.ui- An instance of the PlayerUI class, automatically assigned to each player upon them joining your game. You can control the entirety of the player's in game UI through this. Learn more here: User Interface

player.world- The current world instance in your game that the player is in.

You can find the complete Player API Reference here.

Player Methods
A player instance exposes a number of methods to control their experience in your game with. These range from camera and UI controls, to the ability to force-disconnect them from your game, join a different world instance in your game, and more.

Here's a few notable ones that are most frequently used.

player.disconnect()- Forces the player to disconnect from the game server. Useful for things like kicking players from your game.

player.joinWorld(someWorldInstance)- Connects a player to a provided world instance. If they're already in a world, it will automatically handle removing them from the current world. This is useful for things like teleporting players to different world instances, such as uniquely isolated arenas or dungeons, etc.

player.leaveWorld()- Removed the player from the world they're currently connected to but orphans them. They'll still be connected to your game server but won't visibly see any gameplay or interactions other than chat messages until you explicitly use player.joinWorld()on their player instance to put them into another world.

player.getPersistedData()-  Get the current persisted data object for the player.

player.setPersistedData()- Set any arbitrary object as persisted data for the player. Objects are set using shallow merge. Set data is persisted even after a player leaves a game and will always be retrievable for the given player no matter the instance or lobby of your game they join in the future.

There's a number of other features available, you can find the most up to date documentation of the Player class in the Player API Reference here.

Diving Deeper
The Player class is constantly evolving. You can find the latest Player API Reference here.

If there are features that we don't currently support for Player that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Next Steps
Player Manager

Documentation of the PlayerManager, used to iterate and search all players.

Player Manager
Depending on the type of game you're building, you may need to get a list of all the currently connected players, or filter through players by username or something else. This can be cumbersome to manually track yourself.

Thankfully, we have the PlayerManager that exposes ways to quickly retrieve and iterate all Players connected to your game server, get a player by username if they're connected, and more.

Accessing The PlayerManager
The PlayerManager is used as a singleton and automatically created for the singleton GameServer instance.

You can access the player manager for your game like this:

Copy
PlayerManager.instance
Using The PlayerManager
The PlayerManager exposes a number of ways to get players connected to your game server. Here's some exampels of how to use it.

Copy
// Returns an array of all currently connected
// players for the game server
PlayerManager.instance.getConnectedPlayers();

// Returns a player instance if there is a 
// currently connected player with the provided username.
// If no matching player is found, returns undefined.
PlayerManager.instance.getConnectedPlayerByUsername('someUsername');

// Returns an array of all players
// currently in the provided world.
PlayerManager.instance.getConnectedPlayersByWorld(someWorld);
Diving Deeper
The PlayerManager class is constantly evolving. You can find the latest PlayerManager API Reference here.

If there are features that we don't currently support for PlayerManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Plugins
The HYTOPIA SDK was built from the beginning with best-in-class developer and plugin support in mind. Developers can create their own plugins for themselves, or plugins that other developers can use. This is done by creating packages through NPM (Node Package Manager). 

A HYTOPIA plugin and an NPM package are synonymous. A HYTOPIA plugin is an NPM package, and nearly every NPM package will work as a HYTOPIA plugin so long as it meets the requirements below.

Requirements
At the core, a plugin is just an NPM package that may or may not have a dependency on the HYTOPIA SDK for the features it provides. Whether a plugin offers specific functionality that expands the HYTOPIA SDK, or is just a generic set or utilities, or something else, there are a few unique constraints it must adhere to in order to work as expected.

No External Network Requests - Packages used as plugins cannot make external network requests. The HYTOPIA runtime environment for deployed games explicitly prevents outbound network requests to all but a few whitelisted domains for internal or supported services.

Package Must Be Public - To use an NPM package as a plugin, the package must be published publicly on NPM. This is because HYTOPIA internally performs an bun installof all your declared packages for your game when it is deployed to HYTOPIA's services. We may add support for private org packages in the future, but this isn't currently supported.

Terms Of Use Compliance - HYTOPIA reserves the right to blacklist specific plugins or use cases for plugins at any time in the future. If we believe a specific plugin or implementation pattern is impacting games or services in a way that is clearly not intended for our services, it may be blacklisted. For example, this includes but is not limited to using HYTOPIA services to harvest user data, serving web content separate from a game's experience, or any other use that violates our Developer Terms of Use, etc.

Creating Plugins
There's a number of guides available for creating Node.js packages that can be published to NPM. You can get started by reviewing official docs from npm, here. 

Because a HYTOPIA plugin is an NPM package that conforms to our Requirements, there isn't a difference between creating a regular NPM package and a HYTOPIA plugin - the process is effectively the same.

The functionality exposed by your plugin is entirely up to you. The API developers use to interact with your plugin and how it depends on and interacts with the HYTOPIA SDK is also up to you.

Overall, you have nearly complete freedom to create plugins however you'd like so long as they conform to our Requirements.

Installing Plugins
If there's a plugin you'd like to use with your game, you can install it like any other package from npm. For example, a common utility library that many developers use is lodash. If we want to use lodash as a plugin in our game server, we can install it like so from the root directory of our HYTOPIA project.

Copy
bun add lodash
That's it! When you deploy your game to HYTOPIA's services, our deployment pipeline will look at the dependencies listed in the package.json of your game bundle and attempt to install all dependencies so long as they meet our Requirements.

Physics
Physics are at the core of nearly all game mechanics in HYTOPIA. Physics control how entities interact with each other and their world. 

Nearly every game mechanic starts with physics, but don't worry! HYTOPIA physics were created to be as easy as possible for you to begin working with and understand!


A debug visualization of the rigid body & collider of a player entity, and colliders that make up a world's terrain.
Core Concepts
Let's start with an overview of core concepts within the HYTOPIA physics system.

Colliders - A collider is a shape that can collide with other shapes. A collider could be a "hitbox" of an entity, the shape that approximates terrain in the world that other entities or colliders can collide with, or a sensor that does not physically collide but detects when objects enter and exit its shape.

Collision Groups - Collision Groups allow you fully control if a collider will or will not collide with another collider.

Debugging - Sometimes you'll need to visualize physics. This means being able to see the outlines of colliders, raycasts and rigid bodies in real time. 

Gravity - Simple, gravity! You can fully control gravity in your game. Remove it, change it, make it apply in a different direction, etc.

Raycasts - An invisible line (ray) in physical space that starts at a coordinate, extends in a direction for some provided length, and returns the first entity or block it intersects with, if any. Raycasts are often used for things like seeing if a bullet shot by a player hits another player, if a player is close enough to something to interact with it, and much more.

Rigid Bodies - A rigid body is an object typically made up of 1 or more colliders that interacts with the physical world. The rigid body and its child colliders ultimately define how the rigid body interacts with a world physically. An entity for example is also a rigid body and inherits all its behaviors. Rigid bodies can have linear and rotational forces applied to them, amongst many other things.

Next Steps
Colliders

Learn more about colliders and how they make up the foundation of a world's physical interactions.

Collision Groups

Learn more about collision groups and using them to specify what colliders can and cannot collide.

Debugging 

Learn how to debug physics and enable debug rendering to visualize a world's physics elements.

Gravity

Learn how to change a world's gravity and how it affects a world's physical interactions.

Raycasts

Learn how to use simple raycasts to create exciting game mechanics and behaviors.

Rigid Bodies

Learn more about rigid bodies, applying forces, and controlling their interactions with the physical world.

Colliders
Colliders define invisible 3-dimensional shapes that can collide. They can be attached to an entity or rigid body for hitboxes and relative sensors, or added directly to a world for things like an invisible wall, and much more.

Colliders can have a defined shape, bounciness, friction, mass, relative positioning & rotation to their parent, collision callbacks, and more. These properties together are partly responsible for how physical interactions in a game will happen.

By default, colliders will collide with other colliders when the HYTOPIA engine calculates physics each tick. You can make colliders not collide with each other and only sense intersections by using .


 Visualization of the capsule collider hitbox & slightly large wall capsule collider of a player's entity.
Understanding Collider Options
Collider creation starts with collider options. Whether you're creating a standalone collider, a block type with custom collider options, or a collider as a child of an entity or rigid body (most common), you'll want to get familiar with collider options.

Collider options define things like the colliders shape, dimensions, and how it interacts with the world upon colliding with something.

Here's a list of available collider options, you can find the most up-to-date list in the ColliderOptions API Reference here. 

Property (? = optional)
Type
Description
borderRadius?

number

(Optional) The border radius of the collider if the shape is a round cylinder.

bounciness?

number

(Optional) The bounciness of the collider.

bouncinessCombineRule?

CoefficientCombineRule

(Optional) The bounciness combine rule of the collider.

collisionGroups?

CollisionGroups

(Optional) The collision groups the collider belongs to.

enabled?

boolean

(Optional) Whether the collider is enabled.

friction?

number

(Optional) The friction of the collider.

frictionCombineRule?

CoefficientCombineRule

(Optional) The friction combine rule of the collider.

halfExtents?

Vector3Like

(Optional) The half extents of the collider if the shape is a block.

halfHeight?

number

(Optional) The half height of the collider if the shape is a capsule, cone, cylinder, or round cylinder.

indices?

Uint32Array

(Optional) The indices of the collider if the shape is a trimesh.

isSensor?

boolean

(Optional) Whether the collider is a sensor. Sensors do not collide, allow intersections of other colliders for collision callbacks.

mass?

number

(Optional) The mass of the collider.

onCollision?

CollisionCallback

(Optional) The on collision callback for the collider.

parentRigidBody?

RigidBody

(Optional) The parent rigid body of the collider.

radius?

number

(Optional) The radius of the collider if the shape is a ball, capsule, cone, cylinder, or round cylinder.

relativePosition?

Vector3Like

(Optional) The relative position of the collider. Relative to parent rigid body.

relativeRotation?

QuaternionLike

(Optional) The relative rotation of the collider. Relative to parent rigid body.

shape

ColliderShape

The shape of the collider.

simulation?

Simulation

(Optional) The simulation the collider is in, if provided the collider will automatically be added to the simulation.

tag?

string

(Optional) An arbitrary identifier tag of the collider. Useful for your own logic.

vertices?

Float32Array

(Optional) The vertices of the collider if the shape is a trimesh.

Collider Examples
Here are some examples of how we use collider options to define colliders in different contexts.

Creating an entity with a custom collider.

Copy
const myEntity = new Entity({
  modelUri: 'models/npcs/spider.gltf',
  rigidBodyOptions: { // 
    colliders: [ // Array of collider options, results in a created collider when spawned
      {
        shape: ColliderShape.ROUND_CYLINDER,
        borderRadius: 0.1,
        halfHeight: 0.225,
        radius: 0.5,
        mass: 1, // if not provided, automatically calculated based on shape volume.
        bounciness: 10, // very bouncy!
        relativePosition: { x: 1, y: 0, z: 0 } // acts like an offset relative to the parent. 
      }, 
    ]
  }
});

myEntity.spawn(world, {. x: 0, y: 1, z: 0 });
Creating a block type with custom collider options.

Copy
const myBlockType = new BlockType({
  id: 123,
  name: 'My Custom Block',
  textureUri: 'blocks/dirt.png',
  // block types are special, we cannot provide a shape or shape related
  // collider options since they will be overriden and forced to a trimesh.
  // with a 1x1x1 shape. We can however set things like friction, bounciness,
  // etc.
  customColliderOptions: { 
    friction: 100, // Very high friction block, acts "sticky"
  }
});
Creating a standalone collider as an invisible wall with a callback when entities touch it

Copy
const myCollider = new Collider({
  shape: ColliderShape.BLOCK,
  halfExtents: { x: 1, y: 10, z: 10 },
  // When not a child of rigid body,
  // relative position is relative to the world, 
  // equivalent to a typical world position.
  relativePosition: { x: 20, y: 0, z: -5 }
  onCollision: (other: BlockType | Entity, started: boolean) => {
    if (started) {
      console.log('something touched!');
    } else {
      console.log('something stopped touching!');
    }
  }
});

myCollider.addToSimulation(world.simulation);
Creating a standalone sensor collider with a callback when an entity enters and exits the collider with their own collider.

Copy
const mycollider = new Collider({
  shape: ColliderShape.BLOCK,
  halfExtents: { x: 1, y: 10, z: 10 },
  isSensor: true,
  // When not a child of rigid body,
  // relative position is relative to the world, 
  // equivalent to a typical world position.
  relativePosition: { x: 20, y: 0, z: -5 }
  onCollision: (other: BlockType | Entity, started: boolean) => {
    if (started) {
      console.log('something touched or entered/intersected!');
    } else {
      console.log('something stopped touching or exited/unintersected!');
    }
  }
});

myCollider.addToSimulation(world.simulation);
Collision Groups
Collision groups are a way for you to tell a game physics engine how to categorize colliders so that it can determine which colliders can collide with each other. 

By assigning collision groups to a collider, as well as defining the other collision groups it can interact with, you can fully control what elements of your game do and do not interact with one another.

Collision Group Technicals
If you're familiar with game engines and collision groups, here's a technical breakdown of how HYTOPIA's collision groups operate.

Collision groups are used to determine which objects collide and generate collision and contact force events. 

The automatically assigned default collision groups work great for most entity and block interactions, but you may want to create your own for more complex scenarios. 

Additionally, a collider can belong to an interact with multiple collision groups.

15 collision groups exist. Collision groups use pairwise filtering using bit masks.

This filtering method is based on two 16-bit values:

The belongsTo groups (the 16 left-most bits of `self.0`).

The collidesWith mask (the 16 right-most bits of `self.0`).

An interaction is allowed between two filters `a` and `b` two conditions are met simultaneously:

The belongsTo groups of `a` has at least one bit set to `1` in common with the collidesWith mask of `b`.

The belongsTo groups of `b` has at least one bit set to `1` in common with the collidesWith mask of `a`.

In other words, interactions are allowed between two filter if the following condition is met:

Copy
((a >> 16) & b) != 0 && ((b >> 16) & a) != 0
Collision Groups
Below is a table of each available collision group and an explanation of its purpose. These groups can be accessed through the CollisionGroup enum, here.

Name
Group Value
Purpose
BLOCK

1 << 0

Default group assigned to blocks.

ENTITY

1 << 1

Default group assigned to entity colliders

ENTITY_SENSOR

1 << 2

Default group assigned to entity sensor colliders

PLAYER

1 << 3

Unused by default, but reserved for common player assignment & collider differentiation from regular entities.

GROUP_1

1 << 4

An unused collision group, available for any use.

GROUP_2

1 << 5

An unused collision group, available for any use.

GROUP_3

1 << 6

An unused collision group, available for any use.

GROUP_4

1 << 7

An unused collision group, available for any use.

GROUP_5

1 << 8

An unused collision group, available for any use.

GROUP_6

1 << 9

An unused collision group, available for any use.

GROUP_7

1 << 10

An unused collision group, available for any use.

GROUP_8

1 << 11

An unused collision group, available for any use.

GROUP_9

1 << 12

An unused collision group, available for any use.

GROUP_10

1 << 13

An unused collision group, available for any use.

GROUP_11

1 << 14

An unused collision group, available for any use.

GROUP_12

1 << 15

An unused collision group, available for any use.

ALL

0xFFFF

A special collision group equivalent to all collision groups.

No Player Collision Example
Here's a practical example of using collision groups. In some games, you may want to make it so that players do not collide with other players, and instead pass through each other.

We can do this with collision groups!

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  const playerEntity = new PlayerEntity({
    player,
    name: 'Player',
    modelUri: 'models/players/player.gltf',
    modelLoopedAnimations: ['idle'],
    modelScale: 0.5,
  });

  // Spawn the player entity first, so it has it's
  // default colliders automatically created.
  playerEntity.spawn(world, { x: 0, y: 1, z: 0 });
  
  // Prevent solid colliders (hitbox) from colliding with other Players
  playerEntity.setCollisionGroupsForSolidColliders({
    belongsTo: [ CollisionGroup.PLAYER ],
    collidesWith: [
      CollisionGroup.BLOCK, 
      CollisionGroup.ENTITY, 
      CollisionGroup.ENTITY_SENSOR
    ],
  });
  
  // Prevent sensor colliders from registering intersections
  // with other players. We do this to prevent things like sensor
  // colliders (such as ground sensor) from registering a ground contact
  // if is jumping through an entity or other player.
  playerEntity.setCollisionGroupsForSensorColliders({
    belongsTo: [ CollisionGroup.ENTITY_SENSOR ],
    collidesWith: [
      CollisionGroup.BLOCK,
      CollisionGroup.ENTITY
    ],
  });
});
Debugging
Oftentimes you'll need to visualize your colliders and raycasts to debug your game. The HYTOPIA SDK provides a few ways to do this.

Debugging Colliders
When you need to visualize colliders or sensor colliders, you can enable debug rendering for your game. 

Debug rendering in its current implementation is very performance intensive because it streams all vertices and indices representing the internal physics simulation to all connected clients each tick. Because of this, you'll want to keep debug rendering off unless you need to briefly use it.

You can enable debug rendering as follows.

Copy
startServer(world => {
  world.simulation.enableDebugRendering(true);
  
  // ... other code
});
Debugging Raycasts
If you're using world.simulation.raycast(), you'll almost always want to be able to visualize your raycasts while building and debugging your game. Raycasts, unlike colliders, do not impact performance to render them. You can keep raycast debugging enabled throughout your entire development cycle without any noticable performance impact.

Debug visualization of raycasts will create line in the game that is either black or red. A black line means no object was hit, a red line means an object was hit. Additionally, the line will have a 3D arrow indicating the direction of the raycast.

You can enable debug visualization of raycasts as follows.

Copy
startServer(world => {
  world.simulation.enableDebugRaycasting(true);
  
  // ... other code
});
Gravity
You can change the gravity of your game at any time. 

Gravity is a constant force that effects all rigid bodies with the dynamictype. Learn more about Rigid Bodies.

Changing Gravity
We can change the gravity of a world as follows.

Copy
world.simulation.setGravity({ x: 0, y: -9.81, z: 0 });
The default gravity in HYTOPIA is { x: 0, y: -32, z: 0 }. 

Raycasts
A Raycast is a method of projecting an imaginary line (a "ray) from a specific point in a given direction to detect intersections with objects. You can think of it as a quick way to figure out what object would be "hit" if you fired an infinitely thin laser beam from a certain point in the direction of another point.

If the raycast hit an object, it gives information on the object hit. In HYTOPIA a hit object will be a block or entity. 

If the raycast does not hit an object, it will return null. 

You can control the length of the cast ray, it's origin and direction, and a number of options to ignore certain intersections, and more.

Basic Raycast Example
Here's some basic code showing how we can perform a raycast. Raycasts are performed from the simulation instance of a world as follows.

Copy
const origin = { x: 10, y: 2, z: 0 }; 
const direction = { x: 0, y: 1, z: 0 }; // raycast straight up
const length = 5; // Max length in blocks the ray travels 
const raycastResult = world.simulation.raycast(origin, direction, length);

When debug raycasting is enabled, we can see our raycast in the world. The black arrow point up is the resulting example raycast.
Block Breaking & Placing Example 
Let's make something more useful. How about we setup our players so they can use the left click of their mouse to break blocks in front of the direction their facing, and the right click to place a block.

We can do that as follows.

Copy
// ... other code

// Enable debug raycasting so we can visualize our raycasts for testing
world.simulation.enableDebugRaycasting(true);

world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  const playerEntity = new PlayerEntity({
    player,
    name: 'Player',
    modelUri: 'models/players/player.gltf',
    modelLoopedAnimations: [ 'idle' ],
    modelScale: 0.5,
  });

  // PlayerEntity by default has a PlayerEntityController assigned to .controller,
  // but we explicitly assert that with ! to prevent typescript from complaining.
  playerEntity.controller!.on(BaseEntityControllerEvent.TICK_WITH_PLAYER_INPUT, ({ entity, input, cameraOrientation, deltaTimeMs }) => {
    if (input.ml || input.mr) { // ml = mouse left clicked, mr = mouse right clicked
      const origin = entity.position; // start at the player's current position.
      const direction = entity.player.camera.facingDirection; // cast in the camera direction
      const length = 5;
      const raycastResult = world.simulation.raycast(origin, direction, length, {
        // Prevent the raycast from registering our player entity as the hit object.
        // Raycast options typically work using raw physics engine handles, so we
        // have to use the raw rigid body of our player entity.
        filterExcludeRigidBody: playerEntity.rawRigidBody, 
      });

      if (raycastResult?.hitBlock) { // see if the result hit a block
        if (input.ml) { // left click, break block
          const breakPosition = raycastResult.hitBlock.globalCoordinate;
          world.chunkLattice.setBlock(breakPosition, 0); // 0 = no block/air
        } else { // right click, place block as neighbor of the hit block
          const placePosition = raycastResult.hitBlock.getNeighborGlobalCoordinateFromHitPoint(raycastResult.hitPoint);
          world.chunkLattice.setBlock(placePosition, 1); // 1 = bricks in the default block types
        }
      }

      // Explicitly cancel inputs to prevent raycast spam each tick
      // A player will need to let go of their click and click again
      input.ml = false;
      input.mr = false;
    }
  });
  
  playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
});
Here's a gif showcasing how our block breaking and placing code using raycasts works!


Diving Deeper
Raycasts make use of a few systems. To learn more and understand all of the features of raycasts, we recommend the following resources.

raycast() method API Reference, used to perform a raycast.

RaycastHit type API Reference, returned by raycast() if an object was hit.

RaycastOptions type API Reference, used with raycast() to control its behavior.

If there are features that we don't currently support for raycasts that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Rigid Bodies
A Rigid Body is an object in the physical game world made of 1 or more child colliders and a variety of possible properties. A rigid body is used for anything in a game that moves or responds to forces or collisions from a game physics standpoint. 

It's called a "rigid" body, because it is treated as a solid mass that never bends, stretches or deforms when subjected to forces within the context of our physics engine. A rigid body will always retain it's representative shape made of all its attached child colliders, no matter how significant the forces are that it's subjected to.

Entities & Rigid Bodies
An Entity, is also a Rigid Body. The Entity class inherits from the Rigid Body class. This is very important to remember and will prevent a lot of confusion!

Types Of Rigid Bodies
There are 4 possible types a rigid body can be, defined by RigidBodyType enum, with the default being a dynamicrigid body. The type of a rigid body completely changes the way it behaves.

Here's a breakdown of each of the 4 types.

RigidBodyType.DYNAMIC (Default) - The default type, the rigid body will be effected by all external forces, including collisions with other rigid bodies, colliders, gravity, etc.

RigidBodyType.FIXED - A rigid body that does not move or rotate from collisions or forces. Velocities for example do not effect it. It's position and rotation can be set explicitly with .setRotation()and .setPosition(), but all physical interactions with other elements will have no effect on it and if it's rotation or position are set directly, the change in rotation and position between the current and next tick will not be accounted for during physics resolution.

RigidBodyType.KINEMATIC_POSITION - A rigid body that itself is unaffected by external forces and collisions but can effect other dynamic rigid bodies that contact it. It's velocities (linear and angular), as well as position are assigned each tick with .setNextKinematicPosition()and .setNextKinematicRotation(). The resulting linear and rotational velocities are internally calculated for physics resolution based on the change between the current and next position and rotation.

RigidBodyType.KINEMATIC_VELOCITY - A rigid body that itself is unaffected by external forces and collisions but can effect other dynamic rigid bodies that contact it. Its velocities and positions are updated through with .setLinearVelocity()and .setAngularVelocity(). Its velocities once set will remain constant until explicitly set again by you.

Understanding Rigid Body Options
Rigid Body creation starts with rigid body options. Whether you're creating an entity and providing its EntityOptions with rigid body options (very common), or creating a rigid body directly in a world's physics simulation for a different reason (rarely necessary), you'll want to get familiar with rigid body options.

Rigid body options define things like the rigid body type, velocities, mass, continuous collision detection, allowed movements and rotations, and much more.

Most rigid body properties can be updated at any time through the various methods it provides. You can find this methods in the RigidBody methods API Reference here.

Here's a list of available rigid body options. You can find the most up-to-date list in the RigidBodyOptions API Reference here.

Property (? = optional)
Type
Description
additionalMass?

number

(Optional) The additional mass of the rigid body

additionalMassProperties?

RigidBodyAdditionalMassProperties

(Optional) The additional mass properties of the rigid body.

additionalSolverIterations?

number

(Optional) The additional solver iterations of the rigid body.

angularDamping?

number

(Optional) The angular damping of the rigid body.

angularVelocity?

Vector3Like

(Optional) The angular velocity of the rigid body.

ccdEnabled?

boolean

(Optional) Whether the rigid body has continuous collision detection enabled.

colliders?

ColliderOptions[]

(Optional) The colliders of the rigid body, provided as an array of ColliderOptions.

dominanceGroup?

number

(Optional) The dominance group of the rigid body.

enabled?

boolean

(Optional) Whether the rigid body is enabled.

enabledPositions?

Vector3Boolean

(Optional) The enabled axes of positional movement of the rigid body. Setting an axis to false prevents positional movement on that axis.

enabledRotations?

Vector3Boolean

(Optional) The enabled rotations of the rigid body. Setting an axis to false prevents rotations around that axis.

gravityScale?

number

(Optional) The gravity scale of the rigid body. Defaults to 1, effects how gravity effects the rigid body by gravity * gravityScale.

linearDamping?

number

(Optional) The linear damping of the rigid body.

linearVelocity?

Vector3Like

(Optional) The linear velocity of the rigid body.

position?

Vector3Like

(Optional) The position of the rigid body.

rotation?

QuaternionLike

(Optional) The rotation of the rigid body.

simulation?

Simulation

(Optional) The simulation the rigid body is in. If provided, the rigid body will be automatically added to the simulation.

sleeping?

boolean

(Optional) Whether the rigid body is sleeping.

softCcdPrediction?

number

(Optional) The soft continuous collision detection prediction of the rigid body.

type?

RigidBodyType

(Optional) The type of the rigid body.

Rigid Body Examples
Here are some examples of how we use rigid body options to define rigid bodies in different contexts.

Creating a block entity with all rotations disabled, and positional changes disabled on the x and y axis. It only moves on the Z-axis. 

We'll also add a mass value of 10, which will make it a bit harder to push. Masses in the HYTOPIA engine are calculated by default relative to the non-sensor collider volumes and any additional mass applied to each non-sensor collider of a rigid body, as well as any additional mass of the rigid body overall. All of these masses function together to internally compute center of gravity and other physical properties.

This is great for a situation where we may have to "push" a block into place for a puzzle in a game.

Copy
const heavyBlock = new Entity({
  blockTextureUri: 'textures/stone_bricks.png',
  blockHalfExtents: { x: 0.5, y: 0.5, z: 0.5 },
  rigidBodyOptions: {
    type: RigidBodyType.DYNAMIC,
    additionalMass: 10,
    enabledPositions: { x: false, y: false, z: true },
    enabledRotations: { x: false, y: false, z: false },
  },
});

heavyBlock.spawn(world, { x: -4, y: 10, z: -1 });
Another use of rigid body options could be significantly reducing the effects of gravity for a player entity while keeping it as the default dynamic rigid body type. We can do that as follows.

Copy
const playerEntity = new PlayerEntity({
  player,
  name: 'Player',
  modelUri: 'models/player.gltf',
  modelLoopedAnimations: [ 'idle' ],
  modelScale: 0.5,
  rigidBodyOptions: {
    gravityScale: 0.1
  }
});
Next let's create a block entity in the sky that is constantly spinning. We'll use a kinematic velocity based rigid body and set its initial angular velocity to achieve this. We'll also spawn it in the air since kinematic rigid bodies do not get effected by gravity.

Copy
const spinningBlock = new Entity({
  blockTextureUri: 'textures/stone_bricks.png',
  blockHalfExtents: { x: 1, y: 1, z: 1 }, 
  rigidBodyOptions: {
    type: RigidBodyType.KINEMATIC_VELOCITY,
    angularVelocity: { x: 1, y: 1, z: 1 },
  },
});

spinningBlock.spawn(world, { x: 0, y: 10, z: -6 });
One more common example for good measure. Let's create a block entity that's a platform that moves back and forth. We'll use a kinematic velocity based rigid body that moves back and forth in the air.

Copy
const blockPlatform = new Entity({
  blockTextureUri: 'textures/grass', // A texture URI without a file extension will use a folder and look for the textures for each face in the folder (-x.png, +x.png, -y.png, +y.png, -z.png, +z.png)
  blockHalfExtents: { x: 1, y: 0.5, z: 1 },
  rigidBodyOptions: {
    type: RigidBodyType.KINEMATIC_VELOCITY, // Kinematic means platform won't be effected by external physics, including gravity    
    linearVelocity: { x: 0, y: 0, z: 3 }, // A starting velocity that won't change until we change it explicitly with .setLinearVelocity(), because it's kinematic
  },
});

// Clamp the z range the platform moves back and forth between
blockPlatform.on(EntityEvent.TICK, () => {
  const position = blockPlatform.position;

  if (position.z < -9) {
    blockPlatform.setLinearVelocity({ x: 0, y: 0, z: 3 });
  }

  if (position.z > 8) {
    blockPlatform.setLinearVelocity({ x: 0, y: 0, z: -3 });
  }
});

blockPlatform.spawn(world, { x: 3, y: 3, z: -7 });
Updating Rigid Body Properties
Oftentimes you'll need to perform operations like applying an impulse to a rigid body, adding some amount of force to it, applying an angular velocity, stopping its movement, and more. This may need to be done in response to some in-game action, or something else.

We can easily do this using the variety of methods provided by the rigid body.

Here's how we can apply a impulse of linear force.

Copy
// Multiplying the impulse value by the mass is equivalent to adding
// the same velocity to the entity's current velocity.
// velocityChange = impulse force * mass
myEntity.applyImpulse({ x: 0 , y: 10 * myEntity.mass , z: 0 });
We can also do things like add a torque. Assuming our entity is a dynamic rigid body type, it's angular velocity will increase relative to the torque applied and internally calculated drag/resistance based on its shape determined by all non-sensor child colliders.

Copy
myEntity.addTorque({ x: 0, y: 1, z: 0 })
Rigid bodies expose a number of methods for manipulating their properties at any time in a physically realistic way. Check out the RigidBody methods API Reference here.

Continuous Collision Detection
If an entity or rigid body could have a large force applied to it resulting in a sudden increase linear velocity, or has a very fast velocity, you might notice it seems to "teleport" through walls it should of hit and stopped at. This is due to the entity moving so fast between the current and next tick of physics that it never registers as intersecting a wall in the physics simulation. Or, it goes through a wall far enough between ticks and gets pushed out the other side by physics resolution.

We can easily fix this "tunneling" in our games physics by enabling CCD (Continuous collision detection) on our rigid body.

It might seem tempting to just set ccdEnabled:true on all entities and rigid bodies in your game, but this will cause a noticable degredation of physics performance relative to your number of active rigid bodies. 

We recommend only enabling CCD if you think there is a possibility of tunneling due to high velocities or sudden velocity spikes.

For example, we can enable CCD on an entity as follows.

Copy
const cow = new Entity({
  name: 'cow',
  modelUri: 'models/cow.gltf',
  modelLoopedAnimations: [ 'idle' ],
  modelScale: 0.5,
  rigidBodyOptions: {
    ccdEnabled: true
  }
});
User Interface
One of the toughest parts of game development is crafting great user interfaces (UIs). 

HYTOPIA makes this process remarkably simple. You can build anything from basic menus to highly complex interfaces using standard web tools like HTML, CSS, and JavaScript. If you'd rather work with a framework like React or Svelte, that's no problemâ€”HYTOPIA supports those too! 

One strength that sets HYTOPIA apart is its extremely flexible and unopinionated UI system. If you can create a webpage, you can create the UI for your game. 

Your user interfaces are injected into the same page (DOM) as the HYTOPIA game scene while enabling your user interfaces and your game's server to seamlessly exchange game state, interactions, and data in real time.  

The HYTOPIA game scene and your injected content is loaded in a CSP (Content-Security Policy) controlled iframe, isolating game behavior from any meaningful user data.

All aspects of custom UIs are handled automatically and internally via a WebSocket connection, ensuring everything stays fast and responsive. 

Any interaction you can implement on a webpage can work in your UI!


A custom HYTOPIA Leaderboard UI 
Overlay UI & Scene UIs.
HYTOPIA supports 2 distinct types of user interfaces. Here's the difference between the two.

Overlay UI - The Overlay UI is the global user interface that overlays the game scene. This is great for things like menus, skill bars, leaderboards, countdown timers, visual effects, and other UI elements that do not require spatial placement in the game scene.

Scene UIs -  Scene UIs exist spatially within the 3D game scene itself. They can be attached to entities to follow them, placed at a fixed position, and more. Health bars, entity status icons, quest symbols, NPC messages, and much more are examples of what you could use Scene UIs for. 


A top-right leaderboard that's part of our Overlay UI, and a Scene UI showing a join message above an entity.
Creating & Loading A UI
Both the Overlay UI and Scene UI elements are defined in a single .html file.

In this example, we'll use simple HTML and Javascript to create a basic box on the screen as part of the Overlay UI. As long as your UI is bundled/rendered into an entry .html file, it can be loaded as a HYTOPIA UI regardless of the framework you use.

Make sure to never include <html>, <body>, or <head>tags in your entry .html file!

In your assetsfolder of your project, we'll create a new folder called ui . Within that, create a file called index.html. Your folder and file can be named whatever you like, but for this example we'll keep it simple. Your file should exist at assets/ui/index.html

In your index.htmlfile, let's create a basic box UI - remember, UI's act more or less like a transparently overlayed web page, so we can use HTML, CSS and Javascript for it.

Copy
<div
  style="
    width: 100px;
    height: 100px;
    position: absolute;
    top: 100px;
    right: 100px;
    background-color: #FF0000; 
  "
/>
Now, in our server code, specifically in our world.on(PlayerEvent.Joined_WORLD, ({ player }) => { ... }) event listener, we can load the UI for the player when they join.

Copy
startServer(world => {
  // other code...
  
  world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
    // other code..
    
    player.ui.load('ui/index.html'); // loads relative to assets directory, this resolves to assets/ui/index.html
    
    // other code..
  });
  
  // other code...
});

Boom! That's all we have to do, our UI is fully loaded. 

UI is loaded and controlled on a per-player basis, giving you fine grain controls of what each player sees. 

If you call player.ui.load() again, it will override the previously loaded UI and load a new UI for the player.

Here's what we should see from our example! A red box positioned in the top right of our screen.


UI Example
UIs With Images & Other Assets
If you want to load images in your UI using things like <img /> tag, or load other file types that exist in your assetsfolder, you'll need prefix their relative file path with the magic value {{CDN_ASSETS_URL}} .

For example, let's say in our index.html we have an image we want to load that exists at assets/images/icon.png . We can correctly load it by setting the srcas follows.

Copy
<img src="{{CDN_ASSETS_URL}}/images/icon.png" />
All occurrences of this magic {{CDN_ASSETS_URL}}value are replaced at runtime with the origin server your assets serve from. In local development this origin is your local game server, in production when deployed to HYTOPIA services this will be an arbitrarily assigned CDN url.

You can use this to get the correct URI of any asset type from your assetsdirectory. Stylesheets, images, videos, etc.

Sending & Receiving UI Data
Nearly every client UI and game server needs to be able to receive or send some amount of data. 

Here's how we can do that.

Sending data from server & receiving data in the client UI
We can send a JSON compatible object of any shape to a player's client as follows. 

When sending data, it's sent to a specific player. If you need to send a data update to all players, you can use the PlayerManager to iterate all connected players and send data. In our index.html file.

Copy
player.ui.sendData({
  my: 'data',
  health: 53,
  somethingElse: [ '1', 2, 'three' ]
  // any properties of any JSON compatible shape you want!
});
To receive data on the client, you can use the hytopiaglobal variable in your index.html that is automatically injected by the client and always available when your UI loads.

Copy
<script>
  hytopia.onData(data => {
    console.log(data); // the data object sent from the server to this client ui
  });
</script>
It's that simple! You have full control over the way data is sent and received by players, as well as the shape of the data based on the needs of your game.

Sending data from client UI and receiving data on the server
Similar to how we send data from our server to our client UI, we can send data back from our player's client UI to our server. In our index.html:

Copy
<script>
  hytopia.sendData({
    hello: 'world', 
    clicked: 'button', 
    something: [ 'else' ]
    // any properties of any JSON compatible shape you want!
  });
</script>
We can receive UI data sent from each player's client UI and handle it on the server however we need to with the following:

Copy
// In our game server scripts, anywhere we have a player object we can set the calblack
// Remember, setting the onData callback more than once for a player will override
// the previous set callback for that player!

// Receiving UI data is processed and unique to each player.
player.ui.on(PlayerUIEvent.DATA, ({ playerUi, data }) => {
  // playerUI is the reference to player.ui, the ui of the player the data came from
  // You can get the player the data is from if needed with playerUI.player
  
  // The data object sent from the client UI to the server
  console.log(data);
}
Server to client Scene UI specific state
Scene UIs have their own internally tracked state you can control. Each Scene UIs state is unique to that given instance of the scene UI. 

Scene UI state management is similar to the state patterns of React. Each Scene UI instance can have its own internally tracked state defined by you, and updated directly to trigger UI updates of just that scene element without extra logic. 

You can learn how to use Scene UI state management in Scene UIs.

Using React, Svelte, etc
If you're building more complex UIs with modals, fade effects, and a lot of managed state, you'll likely want to use some popular framework like React, Svelte, etc.

To use one of these frameworks to build a UI, you'll simply need to make sure the output bundles to a .html file that excludes <html>, <head>and <body> tags. Add that file to your assetsfolder, and then load it as ui with player.ui.load()

Sandboxing
The entire game scene, including the UI is loaded for players in a content security policy (CSP) controlled iframe. This sandboxing blocks all external network requests and access to sensitive user data. It effectively acts as a maximum set of isolation around the game and its UI relative to the connected player and their HYTOPIA account.

Next Steps
Overlay UI

Learn more about the Overlay UI that overlay the game scene.

Scene UIs

Learn about Scene UIs that exist in 3D space within the game scene.

Scene UI Manager

Learn more about the Scene UI Manager that tracks and allows lookup of Scene UIs in the world.

Overlay UI
The Overlay UI is exactly what it sounds like. A UI that overlays your game. You can use it to create any type of UI you'd like. 

Overlay UI is loaded into an absolutely positioned <div> on top of the game scene that spans the full width and height of the window.

All Overlay UI is defined in the .html file used to load your UI when invoking player.ui.load()for a player from the server.

Creating A RPG Skills UI Example
We'll use the Overlay UI to create a skills based UI that looks like something that would belong in an RPG (role-playing game) as an overlay in our game.

First, let's make sure we've created our index.htmlfile at assets/ui/index.html.

In our index.html, we'll add the following HTML & CSS to create our UI. In the same exact way you build standard web pages, you can build your HYTOPIA Overlay UI.

Copy
<style>
  .skills-panel {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: linear-gradient(to bottom, rgba(40, 40, 40, 0.92), rgba(25, 25, 25, 0.92));
    border: 3px solid rgba(180, 180, 180, 0.4);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 15px;
    width: 220px;
    backdrop-filter: blur(4px);
  }

  .skill-row {
    display: flex;
    align-items: center;
    margin: 8px 0;
    padding: 6px 8px;
    background: rgba(30, 30, 30, 0.6);
    border: 1px solid rgba(200, 200, 200, 0.15);
    border-radius: 6px;
    transition: all 0.2s ease;
  }

  .skill-row:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateX(-3px);
  }

  .skill-icon {
    width: 32px;
    height: 32px;
    margin-right: 12px;
    background-size: contain;
    background-repeat: no-repeat;
    filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
  }

  .skill-name {
    flex: 1;
    color: #ffffff;
    font-family: 'Trebuchet MS', 'Arial', sans-serif;
    font-size: 15px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    letter-spacing: 0.5px;
  }

  .skill-level {
    font-weight: bold;
    font-size: 16px;
    color: #00ffaa;
    text-shadow: 0 0 8px rgba(0, 255, 170, 0.4),
                 1px 1px 2px rgba(0, 0, 0, 0.8);
    font-family: 'Georgia', serif;
    padding: 0 6px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
  }

  .mining-icon {
    background-image: url('https://static.wikia.nocookie.net/runescape2/images/0/0a/Mining_shop_map_icon.png');
  }

  .woodcutting-icon {
    background-image: url('https://static.wikia.nocookie.net/runescape2/images/8/81/Axe_shop_map_icon.png');
  }

  .fishing-icon {
    background-image: url('https://static.wikia.nocookie.net/runescape2/images/4/4f/Fishing_shop_map_icon.png');
  }

  .combat-icon {
    background-image: url('https://static.wikia.nocookie.net/runescape2/images/4/4a/Sword_shop_map_icon.png');
  }
</style>

<div class="skills-panel">
  <div class="skill-row">
    <div class="skill-icon mining-icon"></div>
    <div class="skill-name">Mining</div>
    <div class="skill-level mining-level">13</div>
  </div>

  <div class="skill-row">
    <div class="skill-icon woodcutting-icon"></div>
    <div class="skill-name">Woodcutting</div>
    <div class="skill-level woodcutting-level">10</div>
  </div>

  <div class="skill-row">
    <div class="skill-icon fishing-icon"></div>
    <div class="skill-name">Fishing</div>
    <div class="skill-level fishing-level">7</div>
  </div>

  <div class="skill-row">
    <div class="skill-icon combat-icon"></div>
    <div class="skill-name">Combat</div>
    <div class="skill-level combat-level">22</div>
  </div>
</div>
Now, on our server, when a player joins our game we'll load the UI file we created for them. 

We can do that as follows.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  player.ui.load('ui/index.html');
  
  // ... other code
});
That's it! That's how easy it is to create a basic Overlay UI in HYTOPIA! 

If all went well, we should see an awesome skills menu that looks like this.


The skills menu overlay UI we created in our example.
Sending Data From Server To UI
In our previous example, we created our skills menu UI, but it doesn't update or change based on gameplay. 

Let's expand on it so that we can communicate things like updates to the player's skill levels from the server.

To do this, we need our UI to listen for data from the server. Here's how we can update our index.htmlfile to listen for this data. Let's add this script to the top of the file

Copy
<!-- Top of our index.html file -->
<script>
  hytopia.onData(data => { // data is any arbitrary object you send from the server
    if (data.type === 'mining-level') {
      document.querySelector('.mining-level').textContent = data.level;
    }

    if (data.type === 'woodcutting-level') {
      document.querySelector('.woodcutting-level').textContent = data.level;
    }

    if (data.type === 'fishing-level') {
      document.querySelector('.fishing-level').textContent = data.level;
    }

    if (data.type === 'combat-level') {
      document.querySelector('.combat-level').textContent = data.level;
    }
  });
</script>

<!-- ... The rest of our index.html from the previous example ... -->
Perfect, our UI is ready to listen for data from our server.

For the sake of showcasing how data works, let's do something simple like set the level of our player's different skills to a random value every second, controlled by the server.

Here's how we can do that.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  player.ui.load('ui/demo.html');

  // Notice that .sendData is specific to the player. We can
  // control sending data uniquely to each individual player as
  // needed through their player.ui
  setInterval(() => {
    player.ui.sendData({ type: 'mining-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'woodcutting-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'fishing-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'combat-level', level: Math.floor(Math.random() * 100) });
  }, 1000);
  
  // ... other code
});
That's it! That's all we have to do to send data to the UI of a specific player.

Here's what we should see in our Overlay UI.


Our updated skills menu Overlay UI, receiving randomized level updates from our server.
Sending Data From UI To Server
Let's end on one final example. We're sending data down to our UI, but what if we need to send data from our UI back to our server?

We can do that as well, and receive that data on the server with a reference to the player it came from, allowing us to fully scope any UI and game behavior specific to each player if necessary.

In our index.htmlfile for our UI that we created in the previous example, we'll add the following to our script.

Copy
<!-- Top of our index.html file -->
<script>
  // Send "ping" data from our UI to server
  // sendData() can send any arbitrary object
  // with any JSON compatible data.
  setInterval(() => {
    hytopia.sendData({ hello: 'world!' });
  }, 2000);
  //////

  hytopia.onData(data => { // data is any arbitrary object you send from the server
    if (data.type === 'mining-level') {
      document.querySelector('.mining-level').textContent = data.level;
    }

    if (data.type === 'woodcutting-level') {
      document.querySelector('.woodcutting-level').textContent = data.level;
    }

    if (data.type === 'fishing-level') {
      document.querySelector('.fishing-level').textContent = data.level;
    }

    if (data.type === 'combat-level') {
      document.querySelector('.combat-level').textContent = data.level;
    }
  });
</script>

<!-- ... The rest of our index.html from the previous example ... -->
Now, on our server we can listen for data from our player like this.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  player.ui.load('ui/demo.html');

  setInterval(() => {
    player.ui.sendData({ type: 'mining-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'woodcutting-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'fishing-level', level: Math.floor(Math.random() * 100) });
    player.ui.sendData({ type: 'combat-level', level: Math.floor(Math.random() * 100) });
  }, 1000);
  
  player.ui.on(PlayerUIEvent.DATA, ({ playerUI, data }) => {
    console.log('got data from this players UI!', data);
    // We can also get the player the data came from by
    // playerUI.player if ever needed.
  });
  
  // ... other code
});
Now, in our server console, we should see a console.log every second for the data sent up from the UI.

That's it! You can expand on these concepts of sending and receiving data however you'd like. The interface for data communication was left intentionally simple and uses generic JSON compatible objects to allow you to create whatever data structures and interactions you need for your specific game.


Explicitly Controlling Pointer Lock
If you need to programmatically unlock a player's cursor lock, which hides their cursor while they're controlling their character in game, we can do that directly from our server code.

By default, a user must press Escapeor Tto unlock their cursor to interact with UI elements. This isn't a great user experience if a menu suddenly pops up for your game, or they interact with something in game that results in a UI change that also requires interaction. They'd have to manually unlock their own pointer with Escape or T, and that's annoying.

On our server, we can lock and unlock a player's cursor at any time with the following code.

Copy
// To unlock their pointer
player.ui.lockPointer(false);

// To lock their pointer
player.ui.lockPointer(true);
Simple! Now, we can better control the UI experience of a player based on everything from in game interactions, UI interactions, and more.

Diving Deeper
The Overlay UI related systems are constantly evolving. You can find the latest PlayerUI API Reference here.

If there are features that we don't currently support for Overlay UI that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Scene UIs
Scene UIs are created with HTML, CSS and Javascript as UI elements within the game scene itself. They can be positioned spatially, follow entities, and more.

They're incredibly flexible and a fantastic way to add another layer of depth to a game. You can use them to create pretty much anything you can imagine - health bars, status symbols that follow entities, quest direction indicators, and so much more.

Creating A Scene UI Template & Instance
All Scene UIs start from a template. A template is defined with the hytopiaglobal's registerSceneUITemplate()method injected into your .html file when it loads in the game client.

Here's an example of how we can create a Scene UI that displays an updating message above a player.

First, we need to register the Scene UI Template with a unique template id the server can reference to tell the client what kind of scene ui to create. We'll give our template an id of my-game-message.

Copy
<!-- index.html, SceneUI templates & overlay UI exist here. -->
<!-- Loaded by the server calling something like player.ui.load(`assets/path/to/index.html`) -->

<script>
  // The first argument of registerSceneUITempalte is the 
  // template id assigned to this template. The second argument
  // is the renderer function used to create a new instance from this
  // template.
  //
  // In the renderer function, id is the scene ui elements unique id, 
  // not the template id. onState is a function we can provide an 
  // onState callback to that will be called anytime the specific
  // instance rendered from our template has a state update.
  hytopia.registerSceneUITemplate('my-game-message', (id, onState) => {
    const template = document.getElementById('my-game-message-template');
    const clone = template.content.cloneNode(true);
    
    // caveat here! Because our game message gets appended to the dom
    // when we return it from this function,
    // using clone.querySelector within onState would return null.
    // So, we create a reference variable to the message element (messageElement)
    // we intend to update in onState so that we can still properly 
    // get the element reference.
    const messageElement = clone.querySelector('.message');
    
    // invoked when the server sends initial state or a state
    // update to this specific scene ui instance created from
    // our template.
    onState(state => {
      messageElement.textContent = state.message;
    });
    
    return clone; // important!! We must return an HTMLElement
  });
</script>

<!-- Our overlay UI that's part of all the rest of our UI could go here, etc... -->

<template id="my-game-message-template">
  <div class="my-game-message">
    <p class="message"></p>
  </div>
</template>

<style>
  .my-game-message {
    background: rgba(0, 0, 0, 0.8);
    border-radius: 12px;
    padding: 12px 20px;
    color: white;
    text-align: center;
    position: relative;
    margin-bottom: 15px;
  }

  .my-game-message:after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid rgba(0, 0, 0, 0.8);
  }

  .my-game-message p {
    font-family: Arial, sans-serif;
    user-select: none;
    font-size: 14px;
    margin: 0;
  }
</style>
Now that we've defined the Scene UI template, our server can tell the client to create an instance of the SceneUI. 

Let's use our SceneUI to create a message above each player that joins our game, setting the message to their username. Then, every second we'll perform a state update unique to each player's specific Scene UI instance we created, showcasing how we can control individual Scene UI state.

Copy
world.on(PlayerEvent.JOINED_WORLD, ({ player }) => {
  // Load the UI file for the joined player that we created above
  player.ui.load('ui/index.html');

  const playerEntity = new PlayerEntity({
    player,
    name: 'Player',
    modelUri: 'models/players/player.gltf',
    modelLoopedAnimations: [ 'idle' ],
    modelScale: 0.5,
  });

  // Create an instance of our SceneUI by the template
  // id we defined in our .html file
  const messageSceneUI = new SceneUI({
    templateId: 'my-game-message',
    attachedToEntity: playerEntity, // It'll follow our entity
    state: { message: player.username },
    offset: { x: 0, y: 1, z: 0 }, // Offset it up slightly so it's above our head
  });

  // Update the state of this Scene UI instance every second.
  setInterval(() => {
    messageSceneUI.setState({
      message: `${player.username} | ${Math.random() * 100}`,
    });
  }, 1000);

  // Load the Scene UI in the world
  messageSceneUI.load(world);
  
  // Spawn the entity
  playerEntity.spawn(world, { x: 0, y: 10, z: 0 });
});
You can also provide other options when creating a new instance of SceneUI for different behaviors. You can find the latest SceneUIOptions API Reference here.

That's it! Here's the result.


The result of our previous example, showing a message bubble with the player's username & a random number updating state.
State Explained
On the server, every Scene UI is represented as an instance of the SceneUI Class. These instances have their own stateproperty which is an arbitrary object holding the most recent state specific to that instance. 

This state can be updated by using the .setState()method of a SceneUI instance. This method expects an arbitrary object of any shape. It will perform a shallow merge between the values provided to .setState()and the existing state object of the instance.

Invoking .setState()will also send the state update to the client, invoking the onState()callback in our template renderer function defined in our .html file, allowing us to control the logic that changes the visual appearance of the SceneUI in game.

Removing Scene UIs
You can remove any SceneUI instance from the game through .unload(). For example

Copy
// ... other code

const messageSceneUI = new SceneUI({
  templateId: 'my-game-message',
  attachedToEntity: playerEntity,
  state: { message: player.username }, // state isn't required, you can also create stateless scene ui.
  offset: { x: 0, y: 1, z: 0 },
});

messageSceneUI.load(world);

setTimeout(() => { // remove our scene UI after 5 seconds
  messageSceneUI.unload();
}, 5000);
SceneUI Interactions, Sending Data From SceneUI To Server
Depending on your game's requirements, you can even make your SceneUI interactable with the player's mouse or for text input within the context of the game scene.

With interactable UI elements, you'll likely want to be able to send data back to the server. in the same way you use hytopia.sendData()to send data in our Overlay UIexamples, you can also use it to send data from interactions with a Scene UI instance.

Here's an example. Assume we have a button SceneUI template that we create. When a player clicks that button, we want to send data back to the server, telling the server what specific button was clicked.

Copy
<script>
  hytopia.registerSceneUITemplate('game-button', (id, onState) => {
    const template = document.getElementById('game-button-template');
    const clone = template.content.cloneNode(true);
    const buttonElement = clone.querySelector('.button');
    
    buttonElement.onclick = () => {
      // Send click event to server
      hytopia.sendData({
        type: 'button-click',
        buttonId: id
      });

      console.log('clicked button!', id);
    };

    return clone;
  });
</script>
and then, on our server, we'll listen for that data, and handle it accordingly to retrieve the correctz SceneUI instance on the server.

Copy
player.ui.on(PlayerUIEvent.DATA, ({ playerUI, data }) => {
  console.log('got data from this players UI!', data);
  if (data.type === 'button-click') {
    const buttonId = data.buttonId as number;    
    const sceneUI = world.sceneUIManager.getSceneUIById(buttonId);
    console.log('got scene ui!', sceneUI);
    // do whatever we want for the click.
  }
});
When interacting with our button, our console.log() in our server code will log the correct instance of the SceneUI for the button that was clicked.


The result of clicking interacting with our Scene UI button and sending data to the server from our example.
Diving Deeper
The SceneUI class is constantly evolving. You can find the latest SceneUI API Reference here.

If there are features that we don't currently support for Scene UI that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Scene UI Manager
It's common for some games to have many different Scene UIs loaded into a game at the same time. This can become difficult to track or manage manually, especially if you need to retrieve and perform updates on specific Scene UI instances.

For this, we have the SceneUIManager that provides ways to quickly retrieve, iterate and update loaded Scene UIs in a world.

Accessing A SceneUIManager
The SceneUIManager is used as a singleton and automatically created for a given world instance.

You can access the Scene UI Manager for a world like this:

Copy
world.sceneUIManager
Using A SceneUIManager
The SceneUIManager exposes a number of ways to get different types of SceneUI instances loaded in a world. Here's a few examples of how you can use it.

Copy
// Returns an array of all loaded scene ui
// instances for the world
world.sceneUIManager.getAllSceneUIs();

// Returns an array of all loaded scene ui
// instances attached to the provided entity.
world.sceneUIManager.getAllEntityAttachedSceneUIs(someEntity);
Diving Deeper
The SceneUIManager class is constantly evolving. You can find the latest SceneUIManager API Reference here.

If there are features that we don't currently support for SceneUIManager that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Worlds
A World is a core part of a HYTOPIA game's lifecycle. You can think of a world as a container for all controls related to gameplay - audio, entities, lighting, physics, chunk terrain, tick loop, and more.

When you start your server, a default world is automatically created and provided for you to use. This world houses everything related to its own gameplay.

Multiple World Instances
Creating additional world instances allows you to create completely isolated game world instances within your server. These instances exist in the same physical server instance. If you've played games like Minecraft, you can think of multiple world instances in a similar way to how Minecraft seperates The Overworld, The Nether, and The End worlds.

By default, players will automatically join into the default world when they join your game, but you can at any point in time join them to another World instance within your server through the player.joinWorld()method, documented in Player Methods.

In nearly all cases, you won't need to use any other world instances besides the default one returned in the callback of startServer(world => {}) . 

Using additional world instances beyond the default world may only make sense in the following situations.

Your game needs to explicitly isolate its physics simulations where isolated world instances could achieve this, since each world runs its own physics simulation.

Your game needs control of environment lighting and visuals in a way that can't be done with a single world. Such as if your game has an overworld with sunny lighting, but also requires another world in "outer space" setting where no lighting, or completely different environmental lighting is required.

For now, we strongly recommend you isolate gameplay to a single world in most cases unless you know what you're doing.

World Management
A World instance exposes all of the managers and various functionality required to control game behavior.

You can find the most up to date list of available managers as properties of a World instance in the World API Reference here.

World Skybox
You can change the skybox of your world by adding cubemap images to an assets/cubemaps/skyboxfolder in your project.

This assets/cubemaps/skyboxfolder should include the following 6 images to use for the skybox.

+x.png

+y.png

+z.png

-x.png

-y.png

-z.png

These 6 images will be used for the 6 faces of the skybox on their appropriately named axes.

If no cubemap is provided by you in a assets/cubemaps/skyboxfolder that you create, then the default skybox will be used.


The default skybox with a light blue color and clouds.
Diving Deeper
The World class is constantly evolving. You Can find the latest World API Reference here.

If there are features that we don't currently support for Worlds that you'd like to see added to the HYTOPIA SDK, you can submit a feature request here.

Map Data Format
One of the most common requirements when building a game with the HYTOPIA SDK is to create a map for the game world. A map is comprised of block coordinates and the definitions of the unique block types of the world. 

Oftentimes, these maps are created and exported as a .json file using https://build.hytopia.com, or other third-party tools.

The format of this file is intentionally simple and verbose, allowing third-party devs to easily create tools to import, modify and export the expected JSON file structure.

Map .json Structure
The map JSON is a single object with 2 top level properties; blockTypes and blocks.

blockTypes - This is an array of objects that define the unique block types of the world. Each object within the array can have any properties from the BlockTypeOptions object type.

blocks - This is an object (also known as a dictionary), that maps global coordinates to a block type ID. An example of an entry is "5,13,-4": 1. Please note that the coordinate key in this example does not have any spaces.

Example map.json
Here's an example of a valid map.json file that can be loaded into a world using world.loadMap().

Note: your assets folder in the root of your project will need to include the texture images defined by the textureUri of each block type, otherwise your block will be black in game due to no findable texture. You can learn more about assets here.

Copy
{
  "blockTypes": [
    {
      "id": 1,
      "name": "Bricks",
      "textureUri": "blocks/bricks.png" // resolves to assets/blocks/bricks.png
    },
    {
      "id": 2,
      "name": "Bouncy Clay",
      "textureUri": "blocks/clay.png"
      "customColliderOptions": {
        "bounciness": 4
      }
    },
    {
      "id": 3,
      "name": "Diamond Ore",
      "textureUri": "blocks/diamond-ore.png"
    },
    {
      "id": 4,
      "name": "Dirt",
      "textureUri": "blocks/dirt.png"
    },
    {
      "id": 5,
      "name": "Dragons Stone",
      "textureUri": "blocks/dragons-stone.png"
    },
    {
      "id": 6,
      "name": "Water",
      "textureUri": "blocks/water.png",
      "isLiquid": true // applies a liquid shader to the texture
    },
    {
      "id": 7,
      "name": "Grass",
      // textureUri when provided a directory will resolve to
      // the following 6 images mapped to the faces of the block.
      // ---
      // assets/blocks/grass/+x.png
      // assets/blocks/grass/+y.png
      // assets/blocks/grass/+z.png
      // assets/blocks/grass/-x.png
      // assets/blocks/grass/-y.png
      // assets/blocks/grass/-z.png
      // ---
      // This allows you to create more unique block types
      // with different textures on each block face.
      "textureUri": "blocks/grass"
    }
  ],
  "blocks": {
    "0,0,0": 2,
    "1,0,0": 2,
    "0,0,1": 2,
    "1,0,1": 2,
    "2,0,0": 7,
    "0,0,2": 7,
    "-2,0,-2": 7,
    "2,0,-2": 7,
    // etc... order doesn't matter.
  },
}
Helpful Resources
HYTOPIA Architecture & Platform Overview
HYTOPIA's game engine - featuring a browser-based client and a Typescript/Javascript SDK for building games - was specifically designed to compete in the evolving UGC games space, with an aim of leverage modern ideas and systems to possibly one day put it on par with titans like Roblox or Minecraft's modding ecosystem. 

Below is an expanded overview of how our architecture enables this next generation of user-created content and multiplayer games:

Fully Server-Authoritative Architecture

Security & Fairness: Because all game state and logic live on the server, including game code which is not replicated to the client, players are unable to spoof positions, teleport, or execute hacks common in less secure architectures. This level of integrity is critical to sustaining fair, competitive environments and ensuring player trust.

Simplified Synchronization: A single source of truth drastically reduces potential sync issues. Developers don't have to worry about reconciling server and client logic or constantly exchanging large state updates.

Scalable, Event-Driven Design

Horizontal Scaling: Our internal hosting architecture is built to scale across multiple servers cost-effectively, automatically handling influxes of new players without compromising performance. Developers can upload their games and be confident that regardless of the number of players, HYTOPIA's systems will scale their game to handle concurrency. This model resembles how platforms like Roblox handle large player counts and high levels of concurrency.

Modular Implementation: We break down core engine capabilities into independent modules within the SDK. This modular approach prevents monolithic code bloat and allows developers to pick and choose which functionalities they need for their game, leading to faster iteration and easier maintenance.

High-Performance Server Stack (Rust/WASM + TypeScript)

Blazing Fast Physics and Compute: Rust compiled to WebAssembly grants near-native performance for CPU-intensive tasks like physics simulation. This ensures smooth gameplay even under heavy loads and many concurrent players.

Friendly Scripting Layer: By exposing scripting in TypeScript (And Javascript), we merge performance with accessibility. Developers can easily hot-reload their code, leverage the extensive NPM ecosystem, and tap into JavaScript's huge knowledge base for rapid prototyping and iteration.

Future-Proofing: Rust/WASM continues to gain traction in modern development, offering opportunities for future optimizations, better concurrency models, and long term stability.

Browser-Based Client

Seamless Access: Players can jump into a HYTOPIA game simply by clicking a link. No downloads, no installersâ€”just instant play. This low-friction approach mirrors the ubiquity of web apps, making HYTOPIA games more likely to be adopted by casual and power users alike.

Three.js & WebGL2 Optimizations: Building on top of Three.js, the client is heavily optimized at the WebGL2 level to handle complex visuals on a wide range of devices. This ensures broad compatibility, from high-end gaming rigs to everyday laptops and mobile devices.

Instant Sharing & Rapid Iteration

Low Barrier to Entry: Removing painful sign-up flows or installation processes means new players can discover and engage with creator-built games much faster. This viral aspect is crucial to sustaining a vibrant user-generated ecosystem.

Real-Time Updates: Developers can update or patch their games on the fly. Since code is centralized on the server and served through a browser client, rolling out improvements or fixing bugs doesn't require massive downloads or user intervention.

Universal Web Technologies (TypeScript / JavaScript)

Developer Familiarity: JavaScript is the world's most commonly used programming language, and TypeScript builds on that familiarity with a type system that improves code quality and maintainability. This drastically lowers the learning curve for new developers.

Rich Plugin Ecosystem: Tapping into the vast NPM ecosystem enables developers to integrate robust libraries and plugins, opening doors to cutting-edge AI features, data analytics, and moreâ€”without reinventing the wheel.

Community-Driven: The open nature of web technologies encourages a thriving community that contributes to tutorials, tools, and frameworks, accelerating innovation and boosting the overall platform.

Future-Proofing for UGC Growth

Event-Driven Flexibility: As player demands evolveâ€”our event-based architecture can adapt quickly without a massive overhaul.

QUIC and Next-Gen Networking: Our planned support for QUIC (and other emerging protocols) paves the way for faster, more reliable connections globally, an essential requirement for real-time experiences in an increasingly distributed world.

Competitive Edge: Modern players and creators expect a frictionless environment where games launch instantly, updates roll out seamlessly, and cheating is minimized. By designing around these expectations from the start, HYTOPIA positions itself as a forward-looking alternative to well-established platforms.

In short, HYTOPIA's architecture merges high-performance, server-authoritative technology with the accessibility of web-based tools. This marriage of power and ease-of-use makes it easier than ever for creators to build, share, and scale multiplayer experiencesâ€”bolstering HYTOPIA as a competitive contender in the fast-growing UGC landscape that Roblox and Minecraft currently dominate.

Useful Third-Party Tools
Here's a list of useful tools for everything from debugging, viewing models, testing, and more.

Cursor Code Editor (https://cursor.com/) - An AI powered code editor that's extremely powerful and can help supercharge your development speed when working with HYTOPIA's SDK.

Blockbench (https://www.blockbench.net/) - A model editing and animation tool that's fully compatible with HYTOPIA. Export your models as .gltf files to use them with HYTOPIA.

GLTF Viewer (https://gltf-viewer.donmccurdy.com/) - A useful tool for viewing GLTF model files, viewing animation names, and more.

Pixabay (https://pixabay.com/music/) - A great source for royalty-free music.

Have a third party tool you think would be useful to list here for others? Submit a request to add it here.

